##v##00.4.50
pagenumber=33
linenumber=185
sellength=0
topline=0
EditHelpFileTitle.Text=Free VCL
form2.STextForeHeadline.Color=16777215
form2.STextForeText.Color=0
form2.STextBackHeadline.Color=12845056
form2.STextBackText.Color=14876671
form2.STextHeadlineFont.Caption=Arial
form2.STextTextFont.Caption=Arial
form2.sTextFontSizeForHeadline.Caption=12
form2.sTextFontSizeForText.Caption=9
form2.CBoxBold.Checked=1
form2.CBoxNoForeColor.Checked=0
form2.CBoxLanguageID.ItemIndex=0
form2.CBoxCharSet.ItemIndex=0
form2.EditContents.Text=Sommaire
form2.EditFrontpageName.Text=Sommaire
form2.CBoxDontMakeFrontpage.Checked=0
form2.EditLogoPath.Text=FreeVcl.bmp
form2.EditFrontpageButtonCaption.Text=Free VCL
form2.RGroupHorizontalAlignment.ItemIndex=0
form2.RGroupVerticalAlignment.ItemIndex=0
form2.CBoxBlankLineBeforeEachHeading.Checked=1
form2.CBoxMakeFrontPageButton.Checked=0
form2.SpinEditFrontpageIDnumber.Value=9999
form2.CBoxAddAboutMenu.Checked=0
form2.EditAboutMenuCaption.Text=&A propos de l'aide...
form2.CBoxPopupPagesForAboutMenu.Tag=-1
form2.EditConstantNameFilePrefix.Text=HLP_
form2.EditConstantNameFileExt.Text=h
form2.CBoxDontMakeHeadersKeywords.Checked=0
form2.CBoxDontMakeTargetsKeywords.Checked=0
copyToPath=
form5.sTextColor1=0
form5.sTextColor2=9743070
form5.sTextColor3=12386403
form5.sTextColor4=255
form5.sTextColor5=8421376
form5.sTextColor6=8650752
form5.sTextColor7=33280
form5.sTextColor8=32896
form5.sTextColor9=13026246
form5.sTextColor10=16711680
form5.sTextColor11=65280
form5.sTextColor12=8651007
form5.sTextColor13=16777215
form5.sTextColor14=16757429
form5.sTextColor15=9764863
form5.sTextColor16=8421504
form5.sTextComment1=
form5.sTextComment2=
form5.sTextComment3=
form5.sTextComment4=
form5.sTextComment5=
form5.sTextComment6=
form5.sTextComment7=
form5.sTextComment8=
form5.sTextComment9=
form5.sTextComment10=
form5.sTextComment11=
form5.sTextComment12=
form5.sTextComment13=
form5.sTextComment14=
form5.sTextComment15=
form5.sTextComment16=
NumOfPages=53
------------ end of project settings / page settings follow ------------
pageC.pages[0].ImageIndex=-1
pageTitle(0).Text=Introduction
getPageConstantLabel(0).Caption=
getPageContentHeaderLabel(0).Caption=
pageKeywords(0).Text=
pageC.pages[1].ImageIndex=-1
pageTitle(1).Text=Configuration
getPageConstantLabel(1).Caption=
getPageContentHeaderLabel(1).Caption=
pageKeywords(1).Text=RTTI;path;lib;include
pageC.pages[2].ImageIndex=-1
pageTitle(2).Text=My first program
getPageConstantLabel(2).Caption=
getPageContentHeaderLabel(2).Caption=
pageKeywords(2).Text=Exemple;FVCL_BEGIN_COMPONENTS;FVCL_END_COMPONENTS;FVCL_BEGIN_EVENTS;FVCL_END_EVENTS;FVCL_ARG_SUPP;FASTCALL;__fastcall;
pageC.pages[3].ImageIndex=-1
pageTitle(3).Text=Properties
getPageConstantLabel(3).Caption=
getPageContentHeaderLabel(3).Caption=
pageKeywords(3).Text=DECLARE_PROPERTY;Property
pageC.pages[4].ImageIndex=-1
pageTitle(4).Text=Events
getPageConstantLabel(4).Caption=
getPageContentHeaderLabel(4).Caption=
pageKeywords(4).Text=DECLARE_EVENT;SET_EVENT;SET_EVENT_STR;
pageC.pages[5].ImageIndex=-1
pageTitle(5).Text=Unicode
getPageConstantLabel(5).Caption=
getPageContentHeaderLabel(5).Caption=
pageKeywords(5).Text=_T;CharString;WideString;AnsiString
pageC.pages[6].ImageIndex=-1
pageTitle(6).Text=Creation of a component
getPageConstantLabel(6).Caption=
getPageContentHeaderLabel(6).Caption=
pageKeywords(6).Text=GetListProperties;GetTypeProperty;GetDefaultProperty;GetProperty;SetProperty
pageC.pages[7].ImageIndex=-1
pageTitle(7).Text=Internationalization
getPageConstantLabel(7).Caption=
getPageContentHeaderLabel(7).Caption=
pageKeywords(7).Text=English;Translate
pageC.pages[8].ImageIndex=-1
pageTitle(8).Text=Known problems
getPageConstantLabel(8).Caption=
getPageContentHeaderLabel(8).Caption=
pageKeywords(8).Text=Bug
pageC.pages[9].ImageIndex=-1
pageTitle(9).Text=Differences between FreeVCL and C++ Builder
getPageConstantLabel(9).Caption=
getPageContentHeaderLabel(9).Caption=
pageKeywords(9).Text=DIALOG;RC;
pageC.pages[10].ImageIndex=-1
pageTitle(10).Text=Exemples de programmes
getPageConstantLabel(10).Caption=
getPageContentHeaderLabel(10).Caption=
pageKeywords(10).Text=TRichEdit;PDF;TCppWebBrowser;TSocketClient;TSocketServer;
pageC.pages[11].ImageIndex=-1
pageTitle(11).Text=Généralités
getPageConstantLabel(11).Caption=CONTENTS
getPageContentHeaderLabel(11).Caption=
pageKeywords(11).Text=
pageC.pages[12].ImageIndex=-1
pageTitle(12).Text=Le menu principal
getPageConstantLabel(12).Caption=MENU
getPageContentHeaderLabel(12).Caption=
pageKeywords(12).Text=
pageC.pages[13].ImageIndex=-1
pageTitle(13).Text=La fenêtre espace de travail
getPageConstantLabel(13).Caption=PROJECTS_WINDOWS
getPageContentHeaderLabel(13).Caption=
pageKeywords(13).Text=projets
pageC.pages[14].ImageIndex=-1
pageTitle(14).Text=La fenêtre d'édition
getPageConstantLabel(14).Caption=EDIT_WINDOW
getPageContentHeaderLabel(14).Caption=
pageKeywords(14).Text=
pageC.pages[15].ImageIndex=-1
pageTitle(15).Text=La fenêtre de résultats
getPageConstantLabel(15).Caption=RESULTS_WINDOW
getPageContentHeaderLabel(15).Caption=
pageKeywords(15).Text=
pageC.pages[16].ImageIndex=-1
pageTitle(16).Text=Le menu fichiers
getPageConstantLabel(16).Caption=
getPageContentHeaderLabel(16).Caption=
pageKeywords(16).Text=
pageC.pages[17].ImageIndex=-1
pageTitle(17).Text=Le menu édition
getPageConstantLabel(17).Caption=
getPageContentHeaderLabel(17).Caption=
pageKeywords(17).Text=
pageC.pages[18].ImageIndex=-1
pageTitle(18).Text=Le menu recherche
getPageConstantLabel(18).Caption=
getPageContentHeaderLabel(18).Caption=
pageKeywords(18).Text=Recherche;Remplacement
pageC.pages[19].ImageIndex=-1
pageTitle(19).Text=Le menu macros
getPageConstantLabel(19).Caption=
getPageContentHeaderLabel(19).Caption=
pageKeywords(19).Text=
pageC.pages[20].ImageIndex=-1
pageTitle(20).Text=Le menu construction
getPageConstantLabel(20).Caption=
getPageContentHeaderLabel(20).Caption=
pageKeywords(20).Text=Construction;Reconstruire;Fenêtre de sortie;
pageC.pages[21].ImageIndex=-1
pageTitle(21).Text=Le menu outils
getPageConstantLabel(21).Caption=
getPageContentHeaderLabel(21).Caption=
pageKeywords(21).Text=Outils;
pageC.pages[22].ImageIndex=-1
pageTitle(22).Text=Le menu options
getPageConstantLabel(22).Caption=
getPageContentHeaderLabel(22).Caption=
pageKeywords(22).Text=Options;
pageC.pages[23].ImageIndex=-1
pageTitle(23).Text=Le menu aide
getPageConstantLabel(23).Caption=
getPageContentHeaderLabel(23).Caption=
pageKeywords(23).Text=Aide;
pageC.pages[24].ImageIndex=-1
pageTitle(24).Text=Installation et configuration
getPageConstantLabel(24).Caption=
getPageContentHeaderLabel(24).Caption=
pageKeywords(24).Text=Installation;Configuration
pageC.pages[25].ImageIndex=-1
pageTitle(25).Text=Espaces de travail
getPageConstantLabel(25).Caption=WORKSPACES
getPageContentHeaderLabel(25).Caption=
pageKeywords(25).Text=Workspace
pageC.pages[26].ImageIndex=-1
pageTitle(26).Text=Création et modification d'un projet
getPageConstantLabel(26).Caption=MODIFPROJECT
getPageContentHeaderLabel(26).Caption=
pageKeywords(26).Text=Projet
pageC.pages[27].ImageIndex=-1
pageTitle(27).Text=Edition de fichiers
getPageConstantLabel(27).Caption=EDITTEXT
getPageContentHeaderLabel(27).Caption=
pageKeywords(27).Text=Editeur
pageC.pages[28].ImageIndex=-1
pageTitle(28).Text=Les marque-pages
getPageConstantLabel(28).Caption=BOOKMARK
getPageContentHeaderLabel(28).Caption=
pageKeywords(28).Text=Marque-page
pageC.pages[29].ImageIndex=-1
pageTitle(29).Text=Modification d'une fenêtre de dialogue
getPageConstantLabel(29).Caption=SAISIEDIALOG
getPageContentHeaderLabel(29).Caption=
pageKeywords(29).Text=Dialogues;Composants;Contrôles;
pageC.pages[30].ImageIndex=-1
pageTitle(30).Text=Les macros
getPageConstantLabel(30).Caption=MACROS
getPageContentHeaderLabel(30).Caption=
pageKeywords(30).Text=Macros-instructions;
pageC.pages[31].ImageIndex=-1
pageTitle(31).Text=Lancement en ligne de commande
getPageConstantLabel(31).Caption=
getPageContentHeaderLabel(31).Caption=
pageKeywords(31).Text=Ligne de commande;
pageC.pages[32].ImageIndex=-1
pageTitle(32).Text=Messages d'information et d'erreur
getPageConstantLabel(32).Caption=DISPLAYERROR
getPageContentHeaderLabel(32).Caption=
pageKeywords(32).Text=Information;Avertissement;Erreur;
pageC.pages[33].ImageIndex=-1
pageTitle(33).Text=Recherche et remplacement
getPageConstantLabel(33).Caption=SEARCHANDREPLACE
getPageContentHeaderLabel(33).Caption=
pageKeywords(33).Text=Recherche;Remplacement;
pageC.pages[34].ImageIndex=-1
pageTitle(34).Text=Saisie de modèles
getPageConstantLabel(34).Caption=SAISIEMODEL
getPageContentHeaderLabel(34).Caption=
pageKeywords(34).Text=Modèles;
pageC.pages[35].ImageIndex=-1
pageTitle(35).Text=Statistiques
getPageConstantLabel(35).Caption=STATISTICS
getPageContentHeaderLabel(35).Caption=
pageKeywords(35).Text=Nombre de lignes;Nombre de caractères;
pageC.pages[36].ImageIndex=-1
pageTitle(36).Text=Conversion de nombres
getPageConstantLabel(36).Caption=CONVERTNUMBERS
getPageContentHeaderLabel(36).Caption=
pageKeywords(36).Text=Décimal;Hexadécimal;Conversion;Float;Big endian;Little endian;
pageC.pages[37].ImageIndex=-1
pageTitle(37).Text=Outils utilisateurs
getPageConstantLabel(37).Caption=SAISIETOOLS
getPageContentHeaderLabel(37).Caption=
pageKeywords(37).Text=
pageC.pages[38].ImageIndex=-1
pageTitle(38).Text=Options générales de l'éditeur
getPageConstantLabel(38).Caption=EDIOPTIONS
getPageContentHeaderLabel(38).Caption=
pageKeywords(38).Text=Options;Parenthèses;Onglets;
pageC.pages[39].ImageIndex=-1
pageTitle(39).Text=Définition des raccourcis
getPageConstantLabel(39).Caption=SAISIERACC
getPageContentHeaderLabel(39).Caption=
pageKeywords(39).Text=
pageC.pages[40].ImageIndex=-1
pageTitle(40).Text=Coloration syntaxique
getPageConstantLabel(40).Caption=SAISIECOLORS
getPageContentHeaderLabel(40).Caption=
pageKeywords(40).Text=Italique;Gras;Couleur du texte;
pageC.pages[41].ImageIndex=-1
pageTitle(41).Text=Police de caractères
getPageConstantLabel(41).Caption=POLICE_FONT
getPageContentHeaderLabel(41).Caption=
pageKeywords(41).Text=Police;Caractères;Fonte
pageC.pages[42].ImageIndex=-1
pageTitle(42).Text=Paramètres de formatage de code
getPageConstantLabel(42).Caption=CODEFORMATPARAMS
getPageContentHeaderLabel(42).Caption=
pageKeywords(42).Text=Formatage de code;
pageC.pages[43].ImageIndex=-1
pageTitle(43).Text=Réponses par défaut
getPageConstantLabel(43).Caption=DEFAULTRESPONSES
getPageContentHeaderLabel(43).Caption=
pageKeywords(43).Text=Ne plus afficher ce message;Réponses automatiques;
pageC.pages[44].ImageIndex=-1
pageTitle(44).Text=Création d'une nouvelle fenêtre de dialogue
getPageConstantLabel(44).Caption=NEWDIALOG
getPageContentHeaderLabel(44).Caption=
pageKeywords(44).Text=Fenêtre de dialogue;
pageC.pages[45].ImageIndex=-1
pageTitle(45).Text=Propriétés d'un contrôle
getPageConstantLabel(45).Caption=PROPRIETES
getPageContentHeaderLabel(45).Caption=
pageKeywords(45).Text=Propriétés;Anchors;Ancrages;Caption;Width;Height;Dimensions d'un contrôle;Visible;
pageC.pages[46].ImageIndex=-1
pageTitle(46).Text=VCL2FreeVCL
getPageConstantLabel(46).Caption=
getPageContentHeaderLabel(46).Caption=
pageKeywords(46).Text=Migration
pageC.pages[47].ImageIndex=-1
pageTitle(47).Text=Visual Studio 6
getPageConstantLabel(47).Caption=
getPageContentHeaderLabel(47).Caption=
pageKeywords(47).Text=
pageC.pages[48].ImageIndex=-1
pageTitle(48).Text=Visual Studio Express
getPageConstantLabel(48).Caption=
getPageContentHeaderLabel(48).Caption=
pageKeywords(48).Text=
pageC.pages[49].ImageIndex=-1
pageTitle(49).Text=Code::Blocks
getPageConstantLabel(49).Caption=
getPageContentHeaderLabel(49).Caption=
pageKeywords(49).Text=
pageC.pages[50].ImageIndex=-1
pageTitle(50).Text=Frequently asked questions
getPageConstantLabel(50).Caption=
getPageContentHeaderLabel(50).Caption=
pageKeywords(50).Text=FAQ;MoveWindow;
pageC.pages[51].ImageIndex=-1
pageTitle(51).Text=Troubleshootings
getPageConstantLabel(51).Caption=
getPageContentHeaderLabel(51).Caption=
pageKeywords(51).Text=Problèmes
pageC.pages[52].ImageIndex=-1
pageTitle(52).Text=History
getPageConstantLabel(52).Caption=
getPageContentHeaderLabel(52).Caption=
pageKeywords(52).Text=
pageC.pages[53].ImageIndex=-1
pageTitle(53).Text=Thanks
getPageConstantLabel(53).Caption=
getPageContentHeaderLabel(53).Caption=
pageKeywords(53).Text=Download;Téléchargement
------------ end of page titles / full text of pages follow ------------
----- SHM ---- page 0 ---- 
<boxl><b>Welcome</b></box>

Free-VCL is a library of components for creating HMI (human-machine interfaces), in other words dialog boxes.

This library was created in order to be compatible with VCL C++ Builder's components. A good knowledge of this software and its components is essential to understand and use Free-VCL. In particular, many elements of the online help C++ Builder are not reproduced in this help. Please refer to help of this software if you want further clarification.

The installation package contains some program samples. They will help you to understand the library functioning.

To work, this library needs a compiler, not included in the installation. I've tested it with Visual Studio, Embedded Visual C++ and Code::block, I suppose it also works with DEV-CPP. It is also possible to do some programs compatibles with C++ Builder, but it needs many macro-functions and redefinitions (in this case we use native VCL). For other compilers, I don't know.

<b><u>Download compilators</u></b>: see <jump=SHM_contents0020>Thanks</jump>
----- SHM ---- page 1 ---- 
After installing FreeVCL, you will almost certainly need to set some options for your compiler.

<chiclet.bmp> <b>headers and libraries path.</b>
This configuration depends on your compiler, but generally you will have to indicate (in options or preferences, for example?) The path of the .H file and of FreeVCL LIB files. Sometime it is in project options. Some softwares don't support relative path, so may be you will have to redefine this parameters before using the samples.

See configuration in <jump=SHM_contents0014>Visual Studio 6</jump>, <jump=SHM_contents0015>Visual Studio Express</jump> or in <jump=SHM_contents0016>Code::Blocks</jump>

<chiclet.bmp> <b>Activate RTTI.</b>
RTTI (Run-time type information) must be enabled in order that many <b><color=10>dynamic_cast</color></b> of the library return correct values. It is the most often in project options, but in Windows CE I had to change it directly in VCP file.
----- SHM ---- page 2 ---- 
We will study together the creation of a minimum programme called "Bonjour mot" (translation of "Hello word", the first who laught of my rotted English will receive my full collection of viruses by e-mail). The complete code of this program is in the directory "Samples\\BonjourMot." 

This programme contains a single window (we'll call it TForm_Principale) were is written "Hello" with a menu which contains the option "close".

<boxl><b>BonjourMot.cpp</b></box>

The first project's file is BonjourMot.cpp. It contains the Windows entry point WinMain. In general, this function is almost always the same, the fastest is to make a copy-paste from another project. When Free-VCL programs will be integrated in an EDI, this file will be generated automatically: 

<b><color=7>//---------------------------------------------------------------------------
// Main function:
//---------------------------------------------------------------------------</color>

<color=10>int</color> PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <color=10>int</color> nCmdShow) \{
  <color=10>int</color> Retour;
  TForm_Principale * Form_Principale;


  <color=10>try</color> \{

    HInstance = hInstance;

    Form_Principale = <color=10>new</color> TForm_Principale(NULL, _T(<color=3>"TForm_Principale"</color>));

    Retour = Application->Run();

    <color=10>delete</color> Form_Principale;

  \}
  <color=10>catch</color> (...) \{

    MessageBox(NULL,
               _T(<color=3>"\\"Bonjour mot\\" have successfully crashed"</color>),
               _T(<color=3>"Exception error"</color>),
               MB_OK | MB_ICONSTOP);

    Retour = -1;

  \}

  <color=10>return</color> Retour;
\}</b>

You have to include the following files:

<onestep.bmp> The file which contains FreeVCL components description:

<b><color=10>#include <FreeVcl.h></color></b>


<onestep.bmp> And the file which will contain the window description (we will see it more later) :

<b><color=10>#include "TForm_Principale.h"</color></b>


<boxl><b>TForm_Principale.dfm</b></box>

Secondly, we must describe the main window. This is done in a file with the extension <b>dfm</b>, <b>TForm_Principale.dfm</b> for example, in our case: 

<b>object Form_Principale: TForm_Principale
  Left = 100
  Top = 50
  Width = 300
  Height = 200
  Constraints.MinWidth = 300
  Constraints.MinHeight = 140
  Position = poScreenCenter
  Caption = 'Bonjour mot'
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  Menu = MainMenu
  OldCreateOrder = False
  DesignSize = (
    866
    598)
  PixelsPerInch = 96
  TextHeight = 13
  object MainMenu: TMainMenu
    Left = 0
    Top = 0
    object MenuItem_Fichiers: TMenuItem
      Caption = 'Fichiers'
      object MenuItem_Quitter: TMenuItem
        Caption = 'Quitter'
        OnClick = MenuItem_QuitterClick
      end
    end
  end
  object Label_Bonjour: TLabel
    Left = 0
    Top = 20
    Width = 300
    Height = 20
    Alignment = taCenter
    Anchors = [akLeft, akTop, akRight]
    Caption = 'Bonjour mot !'
  end
  object Button_Ok: TButton
    Left = 110
    Top = 120
    Width = 80
    Height = 21
    Anchors = [akLeft, akBottom]
    Caption = 'Ok'
    OnClick = Button_OkClick
  end
end

</b>

Again, this file will one day be seized via an interface. For now, it must be entered by hand. The format is exactly the same as the files of the same name in C++ Builder. 

<boxl><b>TForm_Principale.h</b></box>

The class of the main window is described as follows:

<b><color=10>class</color> TForm_Principale : <color=10>public</color> TForm \{
<color=10>private:</color>
<color=10>public:</color>
  FVCL_BEGIN_COMPONENTS
  TMenuItem *MenuItem_Quitter;
  TMenuItem *MenuItem_Fichiers;
  TMainMenu *MainMenu;
  TLabel *Label_Bonjour;
  TButton *Button_Ok;
  FVCL_END_COMPONENTS

  FVCL_BEGIN_EVENTS
  <color=10>void</color> FASTCALL MenuItem_QuitterClick(TObject *Sender);
  <color=10>void</color> FASTCALL Button_OkClick(TObject *Sender);
  FVCL_END_EVENTS

  TForm_Principale(HWND hWndParent, LPSTR szName);
  <color=10>virtual</color> ~TForm_Principale(<color=10>void</color>);
\};
</b>

There are significant differences compared to the equivalent file of C++ Builder:

<bullet.bmp> The keyword <b><color=10>__published</color></b> is not present (this keyword is specific Builder and is not portable). The published objects are in the section <b><color=10>public</color></b>.
<bullet.bmp> The components declaration is framed by the macros <b>FVCL_BEGIN_COMPONENTS</b> and <b>FVCL_END_COMPONENTS</b>. <u><b>Warning</b></u>: These components must be in the same order than in the DFM file, in the order of words <b>end</b> in the case of interlocking components (for example, here, TMenuItem "MenuItem_Fichiers" is after TMenuItem "MenuItem_Quitter" because the keyword <b>end</b> matching with "MenuItem_Fichiers" is after the keyword <b>end</b> matching with"MenuItem_Quitter").
<bullet.bmp> Declarations of events treatment methods are framed by macros <b>FVCL_BEGIN_EVENTS</b> and <b>FVCL_END_EVENTS</b>.
<bullet.bmp> the macro <b>FASTCALL</b> is used instead of keyword <b><color=10>__fastcall</color></b> (again for compatibility between compilers).
<bullet.bmp> The prototype of the constructor of the class is slightly different.
<bullet.bmp> The <b><color=10>#pragma</color></b> specifics Builder are absents.

And we must obviously include the file FreeVCL in begin of file:

<b><color=10>#include <FreeVcl.h></color></b>


<boxl><b>TForm_Principale.cpp</b></box>

The methods are then implemented in the cpp file:

<b><color=8>//---------------------------------------------------------------------------</color>
TForm_Principale::TForm_Principale(HWND hWndParent, LPSTR szName)
  : TForm(hWndParent, szName, FVCL_ARG_SUPP) \{

\}

<color=8>//---------------------------------------------------------------------------</color>
TForm_Principale::~TForm_Principale(<color=10>void</color>) \{
\}

<color=8>//---------------------------------------------------------------------------</color>
<color=10>void</color> TForm_Principale::CallEvent(AnsiString asEvent, TObject *Sender, ...) \{
  BYTE *pArgs;


  pArgs = (BYTE *) &Sender;
  pArgs += <color=10>sizeof</color>(TObject *);

  <color=10>if</color> (asEvent == _T(<color=3>"MenuItem_QuitterClick"</color>)) MenuItem_QuitterClick(Sender);
  <color=10>else if</color> (asEvent == _T(<color=3>"Button_OkClick"</color>)) Button_OkClick(Sender);

\}

<color=8>//---------------------------------------------------------------------------</color>
<color=10>void</color> FASTCALL TForm_Principale::MenuItem_QuitterClick(TObject *Sender) \{
  Close();
\}

<color=8>//---------------------------------------------------------------------------</color>
<color=10>void</color> FASTCALL TForm_Principale::Button_OkClick(TObject *Sender) \{
  Close();
\}

<color=8>//---------------------------------------------------------------------------</color>
</b>

Again, there are some small differences compared to Builder program which would do the same thing:

<bullet.bmp> The constructor of the class is different.
<bullet.bmp> <b>FASTCALL</b> instead of <b><color=10>__fastcall</color></b>, here also.
<bullet.bmp> And most importantly, there is a new method, which must be implemented for all windows (and indeed any object) that can receive events: the method <b>CallEvent</b> (see below).

The method <b>CallEvent</b> is responsible for distribute the events received from components, or possibly from other windows. As always, writing this method should be automatic, but as it is not yet, it's up to you to write it. The body of the function is always the same (a littl' copy-paste is required), only <b><color=10>if</color></b> instructions are to be written. In general, it is not too complicated. For example, if we would have other items in the menu:

<b>  <color=10>if</color> (asEvent == <color=3>"MenuItem_NewFileClick")</color> MenuItem_NewFileClick(Sender);
  <color=10>else if</color> (asEvent == <color=3>"MenuItem_OpenClick"</color>) MenuItem_OpenClick(Sender);
  <color=10>else if</color> (asEvent == <color=3>"MenuItem_SaveClick"</color>) MenuItem_SaveClick(Sender);
  <color=10>else if</color> (asEvent == <color=3>"MenuItem_SaveAsClick"</color>) MenuItem_SaveAsClick(Sender);
  <color=10>else if</color> (asEvent == <color=3>"MenuItem_CloseClick"</color>) MenuItem_CloseClick(Sender);
  ... etc
</b>

Because the prototype of the method with a variable number of arguments, it is more difficult for events that have more than the <b>Sender</b> argument, we must use the macro <b>FVCL_ARG_EVENT</b>. For example, suppose that we have an event <b>OnClose</b> in the DFM: 

<b>  <color=10>else if</color> (asEvent == _T(<color=3>"FormClose"</color>)) \{
    FVCL_ARG_CALLEVENT(TCloseAction *, Action)
    FormClose(Sender, *Action);
  \}
</b>

And for an event <b>OnMouseDown</b> it is squarely the galley:

<b>  <color=10>else if</color> (asEvent == _T(<color=3>"Form_MouseDown"</color>)) \{
    FVCL_ARG_CALLEVENT(TMouseButton, Button)
    FVCL_ARG_CALLEVENT(TShiftState *, Shift)
    FVCL_ARG_CALLEVENT(<color=10>int</color>, X)
    FVCL_ARG_CALLEVENT(<color=10>int</color>, Y)
    Form_MouseDown(Sender, Button, *Shift, X, Y);
  \}
</b>

The rule is easy: for each argument of a method managing one event, use the macro <b>FVCL_ARG_CALLEVENT</b> with the type and name of the argument. Then call the method with variables that you have declared. Except if the argument must be passed by reference (<b>Shift</b> in example above, or <b>Action</b> more hight): in this case the type becomes a pointer to the type (<b>TShiftState *</b> instead of <b>TShiftState</b>), and we pass the address of the variable to the method instead of the variable itself (<b>*Shift</b> instead of <b>Shift</b>).

Don't worry, this method soon will be processed automatically. In the meantime, you must take your head one time and then use abundantly of copy-paste. 

<boxl><b>BonjourMot.rc</b></box>

Finally, we must declare the DFM file in resources. It's very simple, it is as follows in the rc file:

<b><color=10>#include "windows.h"</color>

TFORM_PRINCIPALE DFM MOVEABLE PURE   <color=3>"TForm_Principale.dfm"</color>
</b>

<boxl><b>The project</b></box>

Finally, you must create a project and insert these five sources. To create a project, it depends on your compiler, but in general it's pretty simple. Choose the option "Win32 Application" (or something that resembles) and "create an empty project" (no stdafx and other eccentricities). Insert sources in the project, in link options insert the following files:

<b>libcomdlg32.a</b> or <b>comdlg32.lib</b> (depending)
<b>libcomctl32.a</b> or <b>comctl32.lib</b> (same)
<b>libFreeVcl.a</b> or <b>FreeVcl.lib</b> (you understand)

Compile, run the program, and if everything is ok you should see the following window:

\par\qc\{bmc BonjourMot.bmp\}\par\ql

That's all folks. You've made your first program FreeVCL.

----- SHM ---- page 3 ---- 
The properties allow the user of a component to affect or read a value as if it were a public attribute, but in fact it is a function that is carried out, allowing some treatments that a simple attribute would not. For example, the user will write:
<b>Button->Left = 10;</b>
But in fact, this is equivalent to writing:
<b>Button->Set_Left(10);</b>
And in the <b>Set_Left</b> method, the programmer has scheduled a <b>MoveWindow</b> that makes the button moves effectively after this instruction.

<boxl><b>Declaration</b></box>

In the normal programmes, it is usually not necessary to declare properties. You'll especially need it if you create components.

There are four macro-instructions to declare the properties, depending on their type:

<b><i><u>Read only properties</u></i> :</b>

<b>DECLARE_PROPERTY_GET( base, type, var )</b>

<b><i><u>Read-write properties</u></i> :</b>

<b>DECLARE_PROPERTY( base, type, var )</b>

<b><i><u>Read only array properties</u></i> :</b>

<b>DECLARE_PROPERTY_TAB_GET( base, type, var )</b>

<b><i><u>Read-write array properties</u></i> :</b>

<b>DECLARE_PROPERTY_TAB( base, type, var )</b>

These four macros have for arguments:

<b>base</b> : Name of the class in which the property is defined.
<b>type</b> : Type of Property
<b>var</b> : Name of property

<boxl><b>Implementation</b></box>

The function implementation properties need not be declared (they are automatically in the macro <b>DECLARE_PROPERTY</b>). Their name is determined as follows:

Function used to read the property: <b>Get_</b> + property name.
Function used to write the property: <b>Set_</b> + property name.

For example, for the <b>Left</b> property, prototypes functions are:

<b><color=10>virtual int</color> Get_Left(<color=10>void</color>);
<color=10>virtual bool</color> Set_Left(<color=10>int</color> NewLeft);
</b>

Another example with the <b>Selected</b> property of the <b>ListBox</b> object, which is an array property:

<b><color=10>virtual bool</color> Get_Selected(<color=10>int</color> i);
<color=10>virtual bool</color> Set_Selected(<color=10>int</color> i, <color=10>bool</color> NewSelected);
</b>
----- SHM ---- page 4 ---- 
The events are used to do special treatment when an action is carried out (the most classic example: the user clicks on a button or a menu item). 

<boxl><b>Declaration</b></box>

As the properties, you will generally not need to declare events, unless you create components.

The declaration is very simply done with the following macros:

<b>DECLARE_EVENT_1( event, TypeArgument1 );</b>
<b>DECLARE_EVENT_2( event, TypeArgument1, TypeArgument2 );</b>
<b>DECLARE_EVENT_3( event, TypeArgument1, TypeArgument2, TypeArgument3 );</b>
etc...

Example:

<b>DECLARE_EVENT_1( OnChange, TObject * );</b>

<boxl><b>Calling the event</b></box>

You can call the event exactly like in Builder, as if it is a method:

<b>event ( var1 )</b>
<b>event ( var1, var2 )</b>
<b>event ( var1, var2, var3 )</b>
etc...

<b>event</b>: Event name.
<b>var1, var2, var3, ...</b> : Arguments of the process method.

Example:

<b>OnChange ( <color=10>this</color>)</b>

<boxl><b>Assigning an event</b></box>

The event is usually assigned in the classic manner in DFM, with a line like this:

<b>OnChange = ListBoxChange</b>

Where <b>ListBoxChange</b> is the name of the method to call.

However, it is sometimes necessary to affect an event in a programme. In a file CPP, we uses the macro <b>SET_EVENT</b>:

<b>SET_EVENT(event, base, fnct)</b>

<b>event</b>: Full name of the event (object->event)
<b>base</b> : Object containing the treatment method of the event.
<b>fnct</b> : Name of the treatment method.

Example:

<b>SET_EVENT(ListBox->OnChange, <color=10>this</color>, ListBoxChange);</b>

<boxl><b>Treatment of an event</b></box>

All events are calling the method "CallEvent" of the destination object, this method is responsible to call the appropriate method based on an argument of type <b>AnsiString</b>. The prototype is as follows:

<b><color=10>void</color> CallEvent(AnsiString asEvent, TObject *Sender, ...)</b>

This method eventually calculates the arguments after Sender (when the number of arguments is more than one) and then calls the method corresponding to the event <b>asEvent</b>. The macro <b>FVCL_ARG_CALLEVENT</b> can be used to calculate the arguments following Sender:

<b><color=10>void</color> TObjetDestination::CallEvent(AnsiString asEvent, TObject *Sender, ...) \{
  BYTE *pArgs;


  pArgs = (BYTE *) &Sender;
  pArgs += <color=10>sizeof</color>(TObject *);

  <color=10>if</color> (asEvent == _T(<color=3>"ListBoxChange"</color>)) ListBoxChange(Sender);
  <color=10>else if</color> (asEvent == _T(<color=3>"ListBoxMouseDown"</color>)) \{
    FVCL_ARG_CALLEVENT(TMouseButton, Button)
    FVCL_ARG_CALLEVENT(TShiftState *, Shift)
    FVCL_ARG_CALLEVENT(<color=10>int</color>, X)
    FVCL_ARG_CALLEVENT(<color=10>int</color>, Y)
    ListBoxMouseDown(Sender, Button, *Shift, X, Y);
  \}
  <color=10>else if</color> (asEvent == _T(<color=3>"ButtonClick"</color>)) ButtonClick(Sender);

\}
</b>

When an argument must be passed by reference (&), it is passed by address (*) in the CallEvent. That's why we have a <b>TShiftState *</b> instead of having a <b>TShiftState</b>. Then we have to restore the level of indirection in the call of the processing function (we have therefore <b>*Shift</b>).


----- SHM ---- page 5 ---- 
FreeVCL is totally compatible with unicode (two bytes characters). This was necessary for Windows CE, and can be usefull in your programs.

<boxl><b>Pass to unicode</b></box>

For that, you have to define the preprocessor variable <b>UNICODE</b>. Generally, it's donr in the project options (some softwares do it for you). In worse case, a single <color=10><b>#define UNICODE</b></color> at beginning of your source file should do the job.

<boxl><b>Characters strings</b></box>

When unicode is active, all strings must also be in unicode. Tou may add a <b>L</b> before the characters string to tell that it is unicode:

L<color=3>"ButtonClick"</color>

 But it is better to use the macro-instruction <b>_T</b>. This macro defines strings in unicode if the variable <b>UNICODE</b> is defined, or else in single <color=10>char</color> string. This allow to have a full compatibility between differents compilators and systems:

_T(<color=3>"ButtonClick"</color>)

<boxl><b>AnsiString</b></box>

<b>AnsiString</b>, which are normally some strings of 8 bits characters are changed automatically in unicode if the variable <b>UNICODE</b> is defined. If you really want a type (to write in a file, for example), use the class <b>CharString</b> (Strings of <color=10><b>char</b></color>) or else <b>WideString</b> (unicode), which type don't depends of options. The operator = have been redefined for these classes, and can switch from one type to another.

<u>Note</u>: Therefore, the <b>AnsiString</b> can containning more than ANSI. We keep this name for compatibility only.
----- SHM ---- page 6 ---- 
<b><boxl>The class TFactory</box></b>

The first step to create your own components is to create a descendant of the class TFactory. This class is planned to create a component from its name. Indeed, the name is the only information that the system knows. When FreeVCL treats a DFM file to create a window, it reads, for example, the following line:

<b>object Button_Ok: TButton</b>

Then it asks all descendants of TFactory (which are bound by a chaining system) until it found one capable of creating the object TButton.

When you create a new component, or a group of components, you must create a class derived from TFactory. His name is conventionally <b>TFactory_<i>Something</i></b> (where <b><i>Something</i></b> is, for example, the name of your group of components).

You will then have to implement the two virtual functions:

<b><color=10>bool</color> GetListObjectsVirt(TStrings *ListObjects);</b>
<b>TComponent * CreateObjectVirt(TComponent* AOwner, AnsiString asNom);</b>

<onestep.bmp> The first method indicates the list of components that can create the class. In general, it only makes a <b>Add</b> to the list <b>ListObjects</b>.
<b>
  ListObjects->Add(_T(<color=3>"TComposant1"</color>));
  ListObjects->Add(_T(<color=3>"TComposant2"</color>));
  ListObjects->Add(_T(<color=3>"TComposant3"</color>));
  <color=7>// etc...</color>

  <color=10>return true</color>;
</b>

<onestep.bmp> The second method creates real component. Again, it is usually not very complicated:
<b>
  <color=10>if</color> (asNom == _T(<color=3>"TComposant1"</color>)) <color=10>return new</color> TComposant1(AOwner);
  <color=10>if</color> (asNom == _T(<color=3>"TComposant2"</color>)) <color=10>return new</color> TComposant2(AOwner);
  <color=10>if</color> (asNom == _T(<color=3>"TComposant3"</color>)) <color=10>return new</color> TComposant3(AOwner);
  <color=7>// etc...</color>

  <color=10>return</color> NULL;
</b>

<b><boxl>The component itself</box></b>

Depending on whether your component is graphic or not, contains a Windows window or not, may or may not trigger events, it will derive from a generic class like <b>TComponent</b>, <b>TControl</b>, or <b>TWinControl</b> or from a component more specific as <b>TButton</b>, <b>TEdit</b>, for example. In all cases, it will be a direct or indirect descendant of <b>TComponent</b>. It must implement the following virtual function:
<b>
  <color=10>virtual bool</color> GetListProperties(TStrings *ListProperties);
  <color=10>virtual</color> TYPEPROPERTY GetTypeProperty(AnsiString asProperty, AnsiString *asChoix);
  <color=10>virtual</color> AnsiString GetDefaultProperty(AnsiString asProperty);
  <color=10>virtual</color> AnsiString GetProperty(AnsiString asProperty);
  <color=10>virtual bool</color> SetProperty(AnsiString asProperty, AnsiString asValeur,
                           TPersistent *Sender);
</b>

<onestep.bmp> The method <b>GetListProperties</b> allows the properties editor to list the properties of the object. The implementation of this method should look like this:
<b>
  ListProperties->Add(_T(<color=3>"AutoExpand"</color>));
  ListProperties->Add(_T(<color=3>"BorderStyle"</color>));
  ListProperties->Add(_T(<color=3>"Canvas"</color>));

  <color=10>return</color> TClasseParente::GetListProperties(ListProperties);
</b>

<i><u>Warning</u></i>: at the end of treatment, call the method <b>GetListProperties</b> of the parent class to add to the list its own properties. Each class implements in cascade this method before handing to its parent until the basic object TComponent. Therefore, do not clear the list at the beginning of treatment, because it may be that this method has itself been called by a derived class.

<onestep.bmp> The method <b>GetTypeProperties</b> allows the properties editor to displaying a choice, a checkbox, etc. ..., depending on the type of property.
----- SHM ---- page 7 ---- 
FreeVCL has been specially adapted to facilitate the translation of your programs in different languages, something which is generally impractical with most EDI.


<boxl><b>New methods of TApplication</b></box>

These methods have been added to the class TApplication:


<u>Translate method:</u>

<b>AnsiString Translate(AnsiString asInput);</b>

This method translate a text. It must therefore be called whenever a text is dependent on display language.

Example:

<b>MessageBox(Handle, Application->Translate(<color=3>"Toto fait du vélo"</color>), Application->Translate(<color=3>"C'est un test"</color>), MB_OK);</b>

<u>Méthode ChooseLanguage:</u>

<b><color=10>bool</color> ChooseLanguage(<color=10>void</color>);</b>

This method opens a popup menu to choose a language among all those available. The languages available are those for which a <b>lng</b> file is present in the same directory than the application. This method is generally inserted in the treatment of a user action, for example following a click of a button "language" or a menu option, it seems a good idea.

<u>Méthode SetLanguage:</u>

<b><color=10>bool</color> SetLanguage(AnsiString asNewLanguage);</b>

This method forces a particular language. It is used by the method ChooseLanguage, but it can also be called directly (for example if there is a button for each language).


<boxl><b>In DFM files</b></box>

All visible texts in dialog boxes (labels, caption of buttons, etc. ...) are passing through the <b>Translate</b> method which allows to translate them directly during loading.

Some non-visible properties also automatically call the method Translate. For example <b>HelpFile</b> property is translated, which allows to have a help file for each language.


<boxl><b>The LNG files</b></box>

There is a file LNG per language translation. Their name is the text that will appear in the popup menu of choices. Their content is simply a text format (as a TXT file). The language of reference is the french: it is normal, it is the language easier to learn (Proof? I've learned it without difficulty in three years, whereas in twenty years of hard work I do still speaks English). On each line, so there is the french text and corresponding text in the language file, the two labels are separated by the <b>¤</b> character. The new labels whose programme don't found a translation are automatically added at the end of file, but with the separation <b>µ</b>. You just have to search and translate each line containing this character to fully translate your software.


<boxl><b>How to proceed</b></box>

There are several possible ways to proceed, here is an example:

<onestep.bmp> Copy the file Translate.dll (found in the directory <b>redist</b>) in the same directory as your application. 

<onestep.bmp> Insert the call of the method ChooseLanguage in one way or another in your software (button or menu, you see).

<onestep.bmp> Create, in the same directory as your application, an empty file English.lng with notepad or any text editor. Start your software then choose the English language, then run your program, taking care to open all possible dialogs.

<onestep.bmp> Close your application, then edit a second time the LNG file. You will see that the program automatically added the labels found during the execution of the application. Translate the second part of each line and replace the <b>µ</b> characters by some <b>¤</b>. You can also manually add labels that have not been automatically added (error messages or other messages that do not appear during the normal run). You can in the same way then periodically verify that messages have not been forgotten, or added by changing your software.

<onestep.bmp> Do not forget to include the file Translate.dll in your installation package, and the lng files that you have created.


<boxl><b>Remarks</b></box>

The language is stored in the registry database, and then apply to all applications FreeVCL (of course if a corresponding language file is found).

The file Translate.dll is obviously needed for translation. But if your application does not have to be translated, the dll is not essential to the functioning of the programme. In this case, you can distribute your software without this dll.

The translation is made at load of the window, it is sometimes necessary to leave and return to your program to apply a change of language.
----- SHM ---- page 8 ---- 
Despite my efforts, there is some remaining problems to which I have not found a solution. If you have ideas to solve them, they are welcome.

<b><i><u>Compilation problem with certain properties:</u></i></b>

With the compiler code-block, some instructions are causing some syntax errors at compilation. For example:
<b>i = Button->Caption.ToInt();</b>
cause the following error:
Error: 'struct _dp_GetCaption_SetCaption' has no members named 'ToInt'

<u>Problem workaround</u>:
<onestep.bmp> We must carry out the operation in two stages:
<b>AnsiString asTemp = Button->Caption;
i = asTemp.ToInt();</b>

<onestep.bmp> Or use a cast:
<b>i = ((AnsiString) Button->Caption).ToInt();</b>

<b><i><u>Assigning an array property:</u></i></b>

I have not succeeded in making a read-write array property. When you do "ListBox->Selected[i] = <b><color=10>true</color></b>", the "Selected[i]" is interpreted as a "Get_Selected(i)" (application of operator []) and then the "=" makes a mistake "Non-lvalue in assignment".

<u>Problem workaround</u>: we must use the "Set_..." method, that I have therefore put in<color=10><b>public:</b></color>
<b>ListBox->Set_Selected(i, <color=10>true</color>);</b>

<b><i><u>Reading properties after closing a window:</u></i></b>

It is impossible to read the properties of a control after closing the window (because the GDI objects are destroyed as soon closing). For example, if you do:

<b>MyWindow->Show();
MyWindow->Close();
i = MyWindow->ListBox->ItemIndex;</b>

The underlying GDI object ListBox is destroyed at end of <b>ShowModal</b>, and therefore <b>ItemIndex</b> returns a LB_ERR (ie -1).

<u>Problem workaround</u>:
<onestep.bmp> Solution 1: Store the values in an intermediary variable before the destruction of the window.
<onestep.bmp> Solution 2: In the event <b>OnClose</b> hide the window (<b>Action = caHide</b>) then the controls will not be destroyed.

<u>Note</u>: There is not this probleme when you make a <b>ShowModal</b>, because the window is automatically hidden in the <b>OnClose</b>.

<b><i><u>Events during the construction of a window:</u></i></b>

The window is created in the constructor of the class, the virtual methods are at this moment not yet active. In particular the method <b>OnEvent</b> which distributes the events. As a result, events that occur during this creation are not treated. In particular the method <b>OnActivate</b>, for example.

<u>Problem workaround</u>:
Calling explicitly the treatment method of the event in the constructor of the window.

<b><i><u>Problems assignment of a object-type property:</u></i></b>

When a property refers to another object, this object is not found if it is after the first in the order of creation. For example

<b>object PageControl: TPageControl
  ActivePage = TabSheet1
  ...
  object TabSheet1: TTabSheet</b>

<u>Problem workaround</u>:
<onestep.bmp> Reverse order of creation objects in the DFM file.
<onestep.bmp> Or use other properties if possible (<b>ActivePageIndex</b> in the example above).
----- SHM ---- page 9 ---- 
The syntax and behaviour of objects were intended to be the maximum compatible with C + + Builder. But there are some minor differences, because it was not possible to do otherwise, or for a purpose of improvement.

In addition to differences reported in the preceding pages, here is a list (probably not exhaustive) of differences and improvements:


<boxl><b>On the classes in general</b></box>

<onestep.bmp> FreeVCL being fully programmed in C++, we have no longer derivation limitations that we had in C++ Builder (where a VCL class can not inherit from a non VCL class unless it is virtual pure and without attributes ... Like saying empty).

<onestep.bmp> New Component TTrayIcon to put an icon in the notification area (near the clock).

<onestep.bmp> Classes TForm and TFrame inherits both from TFormFrame class (pooling of code interpretation DFM).

<onestep.bmp> TOpenDialog and TSaveDialog inherits both from TOpenSaveDialog class (pooling of properties).

<onestep.bmp> TMenu inherits from TMenuItem (for pooling of Handle property and construction more simple).

<onestep.bmp> Added a property DragAcceptFiles and an event OnDropFile on all components TWinControl to allow a drag and drop from explorer.


<boxl><b>On strings</b></box>

<onestep.bmp> AnsiString inherits from std::string (therefore all methods of std::string are available).

<onestep.bmp> The management of errors by throwing exceptions is often pervasive, these exceptions have been removed in many places. For example AnsiString.ToInt () does not produce an exception when the chain past in argument is not strictly numeric.

<onestep.bmp> Method "Translate" and call of this method for all DFM texts (to facilitate the internationalization).

<onestep.bmp> CaseSensitive is a property of TStrings (and not only of TStringList).


<boxl><b>On objects</b></box>

<onestep.bmp> TModalResult is an enum rather than #define (more secure programming).

<onestep.bmp> TParaAttributes of TRichEdit has new properties (characters spacing, offset, ...).

<onestep.bmp> TForm et TFrame can read 'DIALOGUE' resources in RC.

<onestep.bmp>  All graphics have LoadFromResourceName method (and not only TBitmaps).

<onestep.bmp> Events OnQueryEndSession and OnEndSession, which are missing in Builder, have be added in object TApplication (process of Windows messages WM_QUERYENDSESSION and WM_ENDSESSION).

<onestep.bmp> New property TApplication->ExePath.

<onestep.bmp> New property RightJustify of TMenuItem to bring a menu on the right of the window.


<boxl><b>EDI Interface</b></box>

Some methods have been added to facilitate the achievement of properties editor. These methods can list, read and write properties, but also to create objects

<b><color=10>bool</color> GetListObjects(TStrings *ListObjects);</b>
List of objects that can be created.

<b>TComponent *CreateObject(TComponent* AOwner, AnsiString asNom);</b>
Creating an object.

<b><color=10>virtual bool</color> GetListProperties(TStrings *ListProperties);</b>
List of published properties.

<b><color=10>virtual</color> TYPEPROPERTY GetTypeProperty(AnsiString asProperty, AnsiString *asChoix);</b>
Reads the type of a property.

<b><color=10>virtual</color> AnsiString GetDefaultProperty(AnsiString asProperty);</b>
Reads the default value of a property.

<b><color=10>virtual</color> AnsiString GetProperty(AnsiString asProperty);</b>
Reads the value of a property.

<b><color=10>virtual bool</color> SetProperty(AnsiString asProperty, AnsiString asValeur, TPersistent *Sender);</b>
Writes a property.


All these methods are described in detail in the DOXYGEN documentation.
----- SHM ---- page 10 ---- 
Here is the list of sample programs provided in installation. This samples are copied in sub-directory "Sample" of install directory. They contains sources files, and projects files on format Visual Studio 6, Code::blocks and when possible, Embedded Visual C. If your compilator is well configured (see <jump=SHM_contents0002>Configuration</jump>), you just have to open the project and compile it to get an exe file. However, there is sometime some problems with relative paths and, depending on your installation directory, you may be will have to change some path (.lib acces, for example).

<b><u>BonjourMot</u></b>

\par\ql\{bml screenshot_BonjourMot.bmp\}\par\ql

Very small program. See all explanations <jump=SHM_contents0003>here</jump>.

<b><u>RTFExpert</u></b>

Little text editor, which allow to read and write RTF files. This program is using FreeVCL_RichEdit library.

<b><u>TestMetafile</u></b>

Create a metafile (EMF)  file which contains a bitmap, some texts and drawings. This program is using FreeVCL_XFiles library.

<b><u>TestPdf</u></b>

Create a PDF file which contains the same components than previous program. This program is using FreeVCL_XFiles library.

<b><u>TestCppWebBrowser</u></b>

Sample of use of TCppWebBrowser object (internet explorer). This program is using FreeVCL_Web library.

<b><u>TestSocket</u></b>

Sample of use of sockets. This project is made of two parts: TestSocketServer and TestSocketClient. This program is using FreeVCL_Web library.

<b><u>TestWebCam</u></b>

\par\ql\{bml screenshot_testwebcam.bmp\}\par\ql

Sample of use of object TWebCam. View and capture of a picture. This program is using FreeVCL_Multimed library.
----- SHM ---- page 11 ---- 
<boxl><b>Free-VCL IDE</b></box>

Free-VCL IDE est l'éditeur permettant de construire des projets Free-VCL, mais également toutes sortes de projets n'utilisant pas nécessairement la librairie Free-VCL.

<bullet.bmp> Sa principale fonction est l'édition de fichiers (texte ou binaires) comprenant la coloration syntaxique, la mise en forme automatique, les macro-fonctions, des modèles de code.

<bullet.bmp> L'éditeur comprend aussi un module de construction de boîtes de dialogues très complet, qui permet de lire et d'écrire les fichiers RC et DFM, ce qui permet une conversion d'un format à l'autre. Il permet également de construire une boîte de dialogue à partir de modèles pré-définis, d'une fenêtre existante (quel que soit le logiciel auquel elle appartient), ou d'une structure.

<bullet.bmp> La partie projet permet de construire un projet de façon arborescente, chaque projet ayant ses dépendances, ce qui permet de construire une branche de l'arbre ou sa totalité en fonction du besoin. Chaque branche n'est construite que si toutes ses dépendances ont été construites avec succès.

<boxl><b>Fenêtre principale</b></box>

La fenêtre principale se décompose en quatres parties principales, qui seront détaillées dans les pages suivantes:

\par\ql\{bml Fenêtre_principale_256.bmp\}\par\ql

<chiclet.bmp> <jump=SHM_contents0002>Le menu principal</jump> (1)

<chiclet.bmp> <jump=SHM_contents0003>La fenêtre espace de travail</jump> (2)

<chiclet.bmp> <jump=SHM_contents0004>La fenêtre d'édition</jump> (3)

<chiclet.bmp> <jump=SHM_contents0005>La fenêtre de résultats</jump> (4)

Ces parties sont séparées par des barres de séparation permettant de redimensionner une partie ou une autre en fonction des besoins.

<boxl><b>Fonctionnalités</b></box>

<chiclet.bmp> <jump=SHM_contents0014>Installation et configuration</jump>

<chiclet.bmp> <jump=SHM_contents0015>Espaces de travail</jump>

<chiclet.bmp> <jump=SHM_contents0016>Création et modification d'un projet</jump>

<chiclet.bmp> <jump=SHM_contents0017>Edition de fichiers</jump>

<chiclet.bmp> <jump=SHM_contents0018>Les marque-pages</jump>

<chiclet.bmp> <jump=SHM_contents0019>Modification d'une fenêtre de dialogue</jump>

<chiclet.bmp> <jump=SHM_contents0020>Les macros</jump>

<chiclet.bmp> <jump=SHM_contents0021>Lancement en ligne de commande</jump>

<boxl><b>Autres boîtes de dialogue</b></box>

<chiclet.bmp> <jump=SHM_contents0022>Messages d'information et d'erreur</jump>

<chiclet.bmp> <jump=SHM_contents0023>Recherche et remplacement</jump> 

<chiclet.bmp> <jump=SHM_contents0024>Saisie de modèles</jump>

<chiclet.bmp> <jump=SHM_contents0025>Statistiques</jump>

<chiclet.bmp> <jump=SHM_contents0026>Conversion de nombres</jump>

<chiclet.bmp> <jump=SHM_contents0027>Outils utilisateurs</jump>

<chiclet.bmp> <jump=SHM_contents0028>Options générales de l'éditeur</jump>

<chiclet.bmp> <jump=SHM_contents0029>Définition des raccourcis</jump>

<chiclet.bmp> <jump=SHM_contents0030>Coloration syntaxique</jump>

<chiclet.bmp> <jump=SHM_contents0031>Police de caractères</jump>

<chiclet.bmp> <jump=SHM_contents0032>Paramètres de formatage de code</jump>

<chiclet.bmp> <jump=SHM_contents0033>Réponses par défaut</jump>

<chiclet.bmp> <jump=SHM_contents0034>Création d'une nouvelle fenêtre de dialogue</jump>

<chiclet.bmp> <jump=SHM_contents0035>Propriétés d'un contrôle</jump>
----- SHM ---- page 12 ---- 
\par\ql\{bml Menu_256.bmp\}\par\ql

<boxl><b>Fichiers</b></box>
Ce menu permer d'ouvrir, d'enregistrer et de fermer des fichiers (textes ou binaires), des boîtes de dialogue, des projets ou des espaces de travail. Les fichiers récemment utilisés peuvent être réouverts en un clic. Il est également possible d'ouvrir un fichier en faisant un drag and drop (glissé-déposé) de ce fichier depuis l'explorateur vers la fenêtre d'édition.

Pour plus de détails, voir <jump=SHM_contents0006>Le menu fichiers</jump>

<boxl><b>Edition</b></box>
Ce menu regroupe les fonction d'édition, c'est à dire les fonctions qui agissent sur le texte du fichier ouvert.
Pour plus de détails, voir <jump=SHM_contents0007>Le menu édition</jump>

<boxl><b>Recherche</b></box>
Fonctions de recherche et de remplacement dans des fichiers.
Pour plus de détails, voir <jump=SHM_contents0008>Le menu recherche</jump>

<boxl><b>Macros</b></box>
Rassemble les fonctions facilitant la saisie de code : les macro-instructions et les modèles de code.
Pour plus de détails, voir <jump=SHM_contents0009>Le menu macros</jump>

<boxl><b>Construire</b></box>
Permet de construire et de lancer les projets.
Pour plus de détails, voir <jump=SHM_contents0010>Le menu construction</jump>

<boxl><b>Outils</b></box>
Regroupe toute une série d'outils pouvant servir ponctuellement, plus des outils que vous pouvez définir vous-même.
Pour plus de détails, voir <jump=SHM_contents0011>Le menu outils</jump>

<boxl><b>Options</b></box>
Permet de paramétrer et de personnaliser les options du programme.
Pour plus de détails, voir <jump=SHM_contents0012>Le menu options</jump>

<boxl><b>Aide</b></box>
Permet de consulter les document d'aide et autres informations (version, contact, ...).
Pour plus de détails, voir <jump=SHM_contents0013>Le menu d'aide</jump>
----- SHM ---- page 13 ---- 
\par\ql\{bml Fenêtre_projets_256.bmp\}\par\ql

Cette fenêtre affiche tous les projets de l'espace de travail. Ces projets sont organisés en arborescence, chaque projet pouvant être dépendant d'autres projets. Vous pouvez faire un clic droit sur un projet ou un fichier, un menu contextuel s'ouvrira. Ce menu vous permet de faire des actions particulières sur les projets.

Voir <jump=SHM_contents0015>Espaces de travail</jump>
----- SHM ---- page 14 ---- 
\par\ql\{bml Fenêtre_édition_256.bmp\}\par\ql

La fenêtre d'édition permet d'éditer plusieurs fichiers, chaque fichier se trouvant dans un onglet. Ceux-ci peuvent êtres disposés sur plusieurs lignes ou sur une seule, en fonction des options de l'éditeur (voir <jump=SHM_contents0028>Options de l'éditeur</jump>).

Vous pouvez ouvrir un fichier dans l'éditeur en faisant juste un glissé-déposé (drag and drop) depuis l'explorateur de fichiers dans la fenêtre d'édition. Le programme détectera automatiquement s'il s'agit d'un fichier texte ou d'un fichier binaire.

Pour plus de détails sur l'édition de fichiers, voir <jump=SHM_contents0017>Edition de fichiers</jump>.
----- SHM ---- page 15 ---- 
\par\ql\{bml Fenêtre_résultats_256.bmp\}\par\ql

Cette fenêtre contient plusieurs onglets qui permettent de visualiser les résultats des recherches, les marque-pages ou le résultat d'une compilation. Généralement, lorsque des lignes de fichiers sont affichés (résultat d'une recherche, erreur de compilation, par exemple), vous pouvez faire un double-clic sur cette ligne pour y accéder directement dans l'éditeur. Le fichier concerné est automatiquement ouvert s'il ne l'était pas déjà, et le curseur se positionne sur la ligne. Il est ensuite possible de faire "référence précédente" ou "référence suivante" (dans le menu édition) pour parcourir successivement toutes les références.
----- SHM ---- page 16 ---- 

<boxl><b>Espaces de travail</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder un espace de travail.

Pour plus de détails, voir <jump=SHM_contents0015>Espaces de travail</jump>.

<boxl><b>Projets</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder un projet.

Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.

<boxl><b>Fichiers</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder un fichier texte ou binaire.

Pour plus de détails, voir <jump=SHM_contents0017>Edtion de fichiers</jump>.

<boxl><b>Dialogues</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder une fenêtre de dialogue.

Pour plus de détails, voir <jump=SHM_contents0034>Création d'une nouvelle fenêtre de dialogue</jump> et <jump=SHM_contents0019>Modification d'une fenêtre de dialogue</jump>.

<boxl><b>Quitter</b></box>
Cette commande permet de quitter le programme. Si vous avez des fichiers modifiés et non sauvegardés, le programme vous proposera de les enregistrer ou d'abandonner vos modifications.

----- SHM ---- page 17 ---- 

<boxl><b>Défaire</b></box>
Défait la dernière opération.
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Refaire</b></box>
Refait la dernière opération défaite.
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Couper</b></box>
Copie le contenu de la sélection dans le presse-papiers, en l'effaçant de l'éditeur.
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Copier</b></box>
Copie le contenu de la sélection dans le presse-papiers, sans modifier la version dans l'éditeur.
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Coller</b></box>
Insère le contenu du presse-papiers à la position du curseur.
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Référence précédente</b></box>
Permet d'afficher la ligne correspondante à la référence précédente dans la fenêtre de résultat.
Pour plus de détails, voir <jump=SHM_contents0005>La fenêtre de résultats</jump>.

<boxl><b>Référence suivante</b></box>
Permet d'afficher la ligne correspondante à la référence suivante dans la fenêtre de résultat.
Pour plus de détails, voir <jump=SHM_contents0005>La fenêtre de résultats</jump>.

<boxl><b>Tout sélectionner</b></box>
Permet de sélectionner tout le contenu de la fenêtre d'édition.
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Aller à la ligne numéro...</b></box>
Permet d'atteindre une ligne précise dans le fichier ouvert. Entrez le numéro de ligne à atteindre.

<boxl><b>Fonctions avancées</b></box>

<u><b>Mettre en minuscules</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<u><b>Mettre en majuscules</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<u><b>Commenter</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<u><b>Décommenter</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Marques-pages</b></box>
Pour plus de détails, voir <jump=SHM_contents0013>Le menu d'aide</jump>

<u><b>Ajouter un marque-page</b></u>
Positionne un marque-page à la position du curseur.
Pour plus de détails, voir <jump=SHM_contents0018>Les marque-pages</jump>.

<u><b>Supprimer un marque-page</b></u>
Supprime le marque-page à la position du curseur.
Pour plus de détails, voir <jump=SHM_contents0018>Les marque-pages</jump>

<u><b>Effacer tous les marque-pages</b></u>
Efface tous les marque-pages.
Pour plus de détails, voir <jump=SHM_contents0018>Les marque-pages</jump>

<boxl><b>Document</b></box>

<u><b>Tabulations -> Espaces</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<u><b>Espaces -> Tabulations</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

<u><b>Supprimer les espaces de fin</b></u>
Pour plus de détails, voir <jump=SHM_contents0017>Edition de fichiers</jump>.

----- SHM ---- page 18 ---- 
<boxl><b>Rechercher</b></box>
Pour plus de détails, voir <jump=SHM_contents0023>Recherche et remplacement</jump>

<boxl><b>Rechercher dans des fichiers</b></box>
Pour plus de détails, voir <jump=SHM_contents0023>Recherche et remplacement</jump>

<boxl><b>Remplacer</b></box>
Pour plus de détails, voir <jump=SHM_contents0023>Recherche et remplacement</jump>

<boxl><b>Remplacer dans des fichiers</b></box>
Pour plus de détails, voir <jump=SHM_contents0023>Recherche et remplacement</jump>

<boxl><b>Rechercher précédent</b></box>
Pour plus de détails, voir <jump=SHM_contents0023>Recherche et remplacement</jump>

<boxl><b>Rechercher suivant</b></box>
Pour plus de détails, voir <jump=SHM_contents0023>Recherche et remplacement</jump>

----- SHM ---- page 19 ---- 
<boxl><b>Enregistrer</b></box>
Enregistre une macro.
Pour plus de détails, voir <jump=SHM_contents0020>Les macros</jump>

<boxl><b>Exécuter</b></box>
Exécute la macro précédemment enregistrée.
Pour plus de détails, voir <jump=SHM_contents0020>Les macros</jump>

<boxl><b>Modèles de code</b></box>
Définition et application de modèles de code.
Pour plus de détails, voir <jump=SHM_contents0024>Modèles de code</jump>
----- SHM ---- page 20 ---- 
<boxl><b>Construire</b></box>
Lance la construction du projet.
Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.

<boxl><b>Reconstruire</b></box>
Lance la construction complète du projet (sans tenir compte des éléments déjà construits).
Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.

<boxl><b>Construire tout</b></box>
Lance la construction de l'ensemble des projets de l'espace de travail.
Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.

<boxl><b>Reconstruire tout</b></box>
Lance la construction complète de l'ensemble des projets de l'espace de travail.
Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.

<boxl><b>Voir la fenêtre de sortie</b></box>
Affiche le résultat de la construction (onglet "traitements" de la fenêtre de résultat). Vous pouvez retrouver la ligne correspondant à un message en faisant un double-clic sur le message d'erreur).
Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.

<boxl><b>Lancer</b></box>
Lance le fichier résultant de la construction. L'effet de ce lancement est variable suivant le type du projet : par exemple si le projet consiste en une compilation de programme, cette commande lance le programme exécutable.
Pour plus de détails, voir <jump=SHM_contents0016>Création et modification d'un projet</jump>.
----- SHM ---- page 21 ---- 
<boxl><b>Statistiques</b></box>
Permet de compter le nombre de lignes dans un programme ou un projet.
Pour plus de détails, voir <jump=SHM_contents0025>Statistiques</jump>.

<boxl><b>Formatage du code</b></box>
Lance le formatage de code sur le fichier ouvert.
Pour plus de détails, voir <jump=SHM_contents0032>Paramètres de formatage de code</jump> et <jump=SHM_contents0017>Edition de fichiers</jump>.

<boxl><b>Conversion de nombres</b></box>
Fenêtre d'aide à la conversion de nombres sous différents formats.
Pour plus de détails, voir <jump=SHM_contents0026>Conversion de nombres</jump>.

<boxl><b>Outils utilisateur</b></box>
Permet de définir et de lancer des programmes externes définis par l'utilisateur.
Pour plus de détails, voir <jump=SHM_contents0027>Outils utilisateur</jump>.
----- SHM ---- page 22 ---- 
<boxl><b>Langue</b></box>

Permet de choisir la langue du programme. Actuellement, seuls le français et l'anglais sont disponibles. Pour que ce changement de langue soit effectif, il vous faudra sortir du programme.

<boxl><b>Options de l'éditeur</b></box>

<u><b>Options générales</b></u>
Options permettant de configurer l'éditeur lui même (espaces et tabulations, affichage des numéros de ligne, etc...).
Pour plus de détails, voir <jump=SHM_contents0028>Options générales de l'éditeur</jump>.

<u><b>Raccourcis clavier</b></u>
Ouvre une boîte de dialogue permettant de définir les raccourcis clavier.
Pour plus de détails, voir <jump=SHM_contents0029>Définition des raccourcis</jump>.

<u><b>Coloration syntaxique</b></u>
Cette boîte de dialogue permet de définir les couleurs de la fenêtre d'édition.
Pour plus de détails, voir <jump=SHM_contents0030>Coloration syntaxique</jump>.

<u><b>Police de caractères</b></u>
Définition de la police de caractères de la fenêtre d'édition (taille, police, etc...).
Pour plus de détails, voir <jump=SHM_contents0031>Police de caractères</jump>.

<u><b>Paramètres de formatage</b></u>
Permet de définir les paramètres de formatage du code.
Pour plus de détails, voir <jump=SHM_contents0032>Paramètres de formatage de code</jump>.

<u><b>Réponses par défaut</b></u>
Permet d'effacer les réponses par défaut enregistrées lorsque vous cochez la case "Ne plus afficher ce message".
Pour plus de détails, voir <jump=SHM_contents0033>Réponses par défaut</jump>.

----- SHM ---- page 23 ---- 
<boxl><b>Aide Free VCL</b></box>
Affiche l'aide de Free VCL, la philosophie générale, des conseils, comment faire un programme, comment configurer le compilateur, etc....

<boxl><b>Aide de l'éditeur</b></box>
Affiche l'aide spécifique à l'éditeur que vous êtes en train de lire.

<boxl><b>Aide en ligne (syntaxe)</b></box>
Affiche l'aide en ligne liée au langage : syntaxe d'une fonction, propriétés et méthodes d'un objet, etc... Cette aide est contextuelle, c'est à dire que si vous positionnez le curseur sur le nom d'une classe, l'aide s'ouvrira sur la page correspondante à cette classe.

<boxl><b>A propos</b></box>
Affiche les informations de version et les informations légales.

<boxl><b>Me contacter</b></box>
Permet d'envoyer un e-mail au support technique. Cette option utilise votre gestionnaire de message, elle ne marchera pas si vous n'en avez aucun de configuré.
----- SHM ---- page 24 ---- 
Le programme d'installation vous propose un répertoire d'installation (par défaut le répertoire des programmes "Program Files"), et configure automatiquement les options par défaut (raccourcis clavier, options de l'éditeur, ...).

Il crée l'arborescence suivante dans le répertoire choisi :

\par\ql\{bml Installation_TreeView_256.bmp\}\par\ql

<bullet.bmp> <u>Bin</u> : Répertoire contenant les exécutables Free VCL, notamment l'éditeur de fichiers <b>FVCLIDE.exe</b>.

<bullet.bmp> <u>Help</u> : Répertoire des fichiers d'aide (celui que vous êtes en tran de lire, entre autres).

<bullet.bmp> <u>Icons</u> : Répertoire contenant les icônes des composants que vous pouvez isérer dans les boîtes de dialogue.

<bullet.bmp> <u>Include</u> : Répertoire des fichiers header à inclure lorsque vous créez un projet Free VCL.

<bullet.bmp> <u>Lib</u> : Fichiers LIB que vous devez lier à vos programmes Free VCL. Ces fichiers sont classés en fonction du compilateur et des options de compilations que vous utilisez :

	<b>VisualStudio</b> : librairies compatibles Visual Studio.
	<b>CodeBlocks</b> : librairies compatibles Code::Blocks

	<b>MBCS_32bits</b> : Chaînes en Multi-Byte Character Set (sur 1 octet pour les caractères courants) et compilation 32 bits.
	<b>UNICODE_32bits</b> : Chaînes en unicode (sur 2 octets) et compilation 32 bits.
	<b>UNICODE_64bits</b> : Chaînes en unicode (sur 2 octets) et compilation 64 bits.

	<b>Release</b> : Signifie que ces fichiers ne contiennent pas les informations de débuggage.

<bullet.bmp> <u>Models</u> : Contient les fichiers modèles, vous pouvez en rajouter si vous le désirez (voir <jump=SHM_contents0024>Saisie de modèles</jump>).

<bullet.bmp> <u>Plugins</u> : Contient les fichiers DLL (librairies dynamiques) correspondant à chaque plugin.

<bullet.bmp> <u>Redist</u> : Contient les seuls fichiers que vous avez le droit de redistribuer dans vos programmes d'installation.

<bullet.bmp> <u>Samples</u> : Petits programmes d'exemple, dont vous pouvez vous inspirer pour vos développements (ces fichiers ne sont pas sous copyright).

<bullet.bmp> <u>Syntax</u> : Contient les mot-clés et les paramètres d'affichage pour chaque extension de fichier.


----- SHM ---- page 25 ---- 
Un espace de travail est un ensemble de projets. Les projets sont organisés en arborescence dans l'espace de travail, chaque projet pouvant dépendre d'un ou plusieurs autres projets. L'espace de travail est automatiquement sauvegardé lorsque vous quittez le programme, sauf si vous avez lancé le programme avec une ligne de commande.

Un projet a des fichiers d'entrée et un fichier de sortie. A son tour, le fichier de sortie peut servir de fichier d'entrée à un autre projet. C'est grâce à ce mécanisme que le programme détermine les projets à construire.

Lorsque vous donnez l'ordre de construire un projet, le programme regarde avant si tous les projets qui en dépendent sont à jour. S'ils ne sont pas à jour, il lance leur construction de la même façon, récursivement. Si une construction échoue, le traitement s'arrête.

Ensuite, le programme compare la date des fichiers d'entrée à la date du fichier de sortie. Si un des fichiers d'entrée (ou le projet lui-même) est plus récent que le fichier de sortie, ça signifie qu'une modification est intervenue sur ce fichier, ou bien sur un des projets qui crée ce fichier. Le programme reconstruit alors le projet. Sinon, cela signifie qu'il est déjà à jour et que le traitement est terminé.

Vous pouvez ainsi créer toute une chaîne de traitements, le programme déterminera automatiquement les traitements à effectuer dès que vous ferez une modification sur un fichier. Prenons un cas concret classique : vous souhaitez mettre en ligne sur un site web le setup d'installation d'un programme (c'est comme ceci que FreeVCL est mis à disposition, par exemple). Le processus complet nécessite trois traitements successifs:

<onestep.bmp> La compilation des programmes.

<onestep.bmp> La construction du setup d'installation.

<onestep.bmp> La copie de ce setup sur le site via FTP.

Nous aurons donc ces projets organisés comme ceci :

<onestep.bmp> La copie du setup est la dernière étape du processus. Il est donc au niveau supérieur (directement sous le noeud racine).

<onestep.bmp> La construction du setup est nécessaire avant de faire la copie. Il est donc au niveau juste en dessous (noeud enfant du projet "copie")

<onestep.bmp> La compilation de chaque programme est nécessaire avant le setup. Chaque compilation est donc au niveau encore en dessous.

Un clic droit sur un projet fait apparaitre un menu contextuel avec les options suivantes :

\par\qc\{bmc FenêtreProjets_Popup_256.bmp\}\par\ql

<onestep.bmp> <b>Tout développer</b> : développe le noeud et tous ses noeuds enfant, récursivement.

<onestep.bmp> <b>Tout réduire</b> : réduit le noeud et tous ses noeuds enfants.

<onestep.bmp> <b>Ajouter un nouveau projet</b> : Crée un nouveau projet en tant que dépendance du projet sélectionné (c'est à dire comme noeud enfant).

<onestep.bmp> <b>Ajouter un projet existant</b> : Insère un projet existant en tant que dépendance.

<onestep.bmp> <b>Renommer</b> : permet de renommer le projet (le nom affiché dans l'arborescence).

<onestep.bmp> <b>Enlever</b> : supprime le projet. Cette option est grisée si le projet contient des sous-projets.

<onestep.bmp> <b>Modifier</b> : permet de modifier le projet. 

<onestep.bmp> <b>Editer le fichier projet</b> : ouvre le fichier projet comme un fichier texte dans l'éditeur.

<onestep.bmp> <b>Construire ce projet</b> : construit le projet et éventuellement les sous-projets en fonction des dates des fichiers d'entrée et de sortie.

<onestep.bmp> <b>Reconstruire ce projet</b> : reconstruit entièrement le projet et les sous-projets indépendamment des dates des fichiers.

<onestep.bmp> <b>Voir le fichier de sortie</b> : ouvre le fichier de sortie dans l'éditeur.
----- SHM ---- page 26 ---- 
Vous pouvez créer un projet de plusieurs façons différentes : par le menu ou bien en faisant un clic droit sur un projet déjà existant dans l'espace de travail, puis "Ajouter un nouveau projet". Dans tous les cas, le nouveau projet est un noeud enfant (dépendance) du projet sélectionné.

Une boîte de dialogue s'ouvre, dans laquelle vous pouvez entrer le nom et le type du projet. Le nom est celui qui apparaitra dans l'arborescence. Les types de projets listés correspondent aux plug-ins installés (chaque plug-in = un type de projet). Il existe des types de projets pour toutes les actions courantes qu'on peut rencontrer dans un travail informatique : copie, transfert FTP,  construction du setup, etc...

\par\qc\{bmc CreationProjet_Ajout_256.bmp\}\par\ql

La fenêtre qui s'ouvre ensuite dépend du type de projet que vous avez choisi. Par exemple, pour une copie de fichier, il faut entrer le fichier de départ et le fichier destination (voir ci-dessous)

Le programme ajoute automatiquement les fichiers dont dépend le projet. Vous pouvez en ajouter d'autres si nécessaire. La modification d'un de ces fichiers aura pour effet d'entrainer la reconstruction du projet lorsqu'on reconstruira un projet de niveau supérieur ou égal.

<boxl>Commande DOS</box>

Effectue une commande DOS. Entrez la commande et les arguments.

<boxl>Copie de fichier</box>

Fait une simple copie de fichiers d'un fichier source à un fichier destination. Le fichier d'entrée est le fichier source, et le fichier de sortie est le fichier destination.

<boxl>Synchronisation FTP</box>

Ce type de projet permet de synchroniser un répertoire local avec un site distant par FTP. Entrez les informations suivantes :

<bullet.bmp> Sens de transfert :

<bullet.bmp> Répertoire local : Entrez le nom complet du répertoire local.

<bullet.bmp> Répertoire distant : Entrez l'adresse du site FTP.

<bullet.bmp> Mot de passe : Entrez le mot de passe permettant l'accès au site FTP.

<bullet.bmp> Port : Entrez le numéro de port pour l'accès au site (généralement port 21).
----- SHM ---- page 27 ---- 
<boxl>Les raccourcis claviers</box>

Vous pouvez utiliser les raccourcis communs à tous les éditeurs. Sans entrer dans les détails (vous êtes supposés savoir vous servir d'un éditeur), on rappellera juste les plus utiles :

<bullet.bmp> CTRL + X : copie le texte sélectionné dans le presse-papiers et le supprime.
<bullet.bmp> CTRL + C : copie le texte sélectionné dans le presse-papiers sans modification du fichier.
<bullet.bmp> CTRL + V : copie le contenu du presse-papier à la position du curseur.

<bullet.bmp> CTRL + flèche haut : déplacement de la fenêtre vers le haut sans déplacer le curseur.
<bullet.bmp> CTRL + flèche bas : déplacement de la fenêtre vers le bas sans déplacer le curseur.
<bullet.bmp> CTRL + flèche droite : déplacement de mot en mot vers la droite.
<bullet.bmp> CTRL + flèche gauche : déplacement de mot en mot vers la gauche.

Sélection rectangulaire : permet de sélectionner un bloc rectangulaire de texte :

\par\ql\{bml Raccourcis_RectSelect_256.bmp\}\par\ql

Cette sélection peut être faite de deux façons :

<bullet.bmp> Tenir CTRL + ALT enfoncés. Presser le bouton gauche de la souris sur un premier coin du rectangle et le relâcher sur l'autre coin. Relâcher CTRL + ALT.
<bullet.bmp> Tenir SHIFT + ALT enfoncés. Cliquer un premier coin du rectangle (clic gauche de la souris) puis cliquer l'autre coin du rectangle. Relâcher SHIFT + ALT.

Il est ensuite possible de copier, coller, supprimer ou remplacer ce bloc de texte comme n'importe quelle sélection.

<boxl>Menu contextuel</box>

<u>Couper</u> : Coupe le texte sélectionné dans le presse-papiers.

<u>Copier</u> : Copie le texte sélectionné dans le presse-papiers.

<u>Coller</u> : Insère le contenu du presse-papiers à la position du curseur.

<u>Positionner un marque-page</u> : Insère un marque-pages sur la ligne du cuseur.

<u>Positionner un point d'arrêt</u> : Insère un point d'arrêt sur la ligne du curseur.

<u>Sélectionner le bloc</u> : Sélectionne le bloc entier contenant le curseur. Les délimiteurs de blocs dépendent du langage, ça peut être les accolades ouvrantes et fermantes, ou les mots clé <color=10><b>begin</b></color> et <color=10><b>end</b></color>. La sélection gère l'imbrication de blocs et sélectionne toujours un bloc complet (contenant autant de débuts de blocs que de fins).

<u>Sélectionner la parenthèse</u> : Sélectionne la parenthèse contenant le curseur. La sélection gère l'imbrication de parenthèses et sélectionne toujours une parenthèse complète (contenant autant de parenthèses ouvrantes que fermantes).

Si le texte sous le curseur est un nom de fichier, il est possible de l'ouvrir avec un simple clic : 

\par\ql\{bmc TextEditor_RightClick1_256.bmp\}\par\ql

Si le texte sélectionné est un nombre, il est possible de le convertir automatiquement en hexadécimal, ou bien inversement en décimal :

\par\ql\{bmc TextEditor_RightClick2_256.bmp\}\par\ql
----- SHM ---- page 28 ---- 
Les marque-pages permettent de retrouver rapidemment des points précis dans vos programmes et fichiers. Positionnez des marque-pages aux endroits qui vous intéressent. Il sont listés dans un onglet de la fenêtre de résultat.

Il y a plusieurs façons de positionner un marque-page : vous pouvez faire un clic droit sur la ligne et sélectionner "positionner un marque-page", sélectionner la commande "positionner un marque-page" dans le menu "édition", ou bien utiliser un raccourci clavier (par défaut CTRL + K).

Les marque-pages sont symbolisés par l'icône suivante dans la colone d'icônes (à condition que la colonne des icônes d'état soit visible, voir <jump=SHM_contents0028>Options générales de l'éditeur</jump>) :
\par\ql\{bml Icone_MarquePages_256.bmp\}\par\ql

Une fois les marque-pages positionnés, vous pouvez soit aller directement à un marque-page précis en faisant un double-clic sur la ligne, soit les parcourir successivement en faisant "référence suivante" ou "référence précédente" dans le menu d'édition (commandes généralement appelées avec les raccourcis F4 et Maj + F4).

Vous avez bien sûr la possibilité d'effacer un marque-page, ou bien la totalité des marque-pages (commande du menu "édition").
----- SHM ---- page 29 ---- 
Cette partie permer de créer et de modifier les boîtes de dialogue VCL. Vous pouvez soit créer une nouvelle fenêtre à partir des modèles proposés ou d'une fenêtre existante, soit ouvrir un fichier RC ou DFM.

Pour plus de détails sur la création d'une nouvelle boîte de dialogue, voir <jump=SHM_contents0034>Création d'une nouvelle fenêtre de dialogue</jump>.

Cette partie création contient plusieurs éléments permettant la construction et la modification des éléments :

<boxl>Tree-view des composants</box>

Dans la partie gauche, un tree-view (arborescence) contient les boîtes de dialogues et leurs composants.

Ce tree-view contient au niveau 0 le ou les boîtes de dialogue. Dans le cas d'un fichier RC, on peut avoir plusieurs boîtes dans un même fichier. Dans le cas d'un DFM, il ne peut y avoir qu'une seule boîte par fichier. Ensuite, chaque boîte ou composant contient ses composants enfants.

Vous pouvez visualiser une boîte par un double-clic sur le noeud correspondant. La fenêtre apparait et est mise au premier plan.

Vous pouvez sélectionner un composant en cliquant dessus dans l'arborescence. Il est automatiquement sélectionné dans la boîte de dialogue elle-même. Un entourage de couleur permet de voir quels composants sont sélectionnés. Pour sélectionner plusieurs composants en même temps, sélectionnez d'autres composants en tenant le touche CTRL ou MAJ enfoncée.

<boxl>Menu contextuel</box>

Un clic droit sur un noeud de l'arborescence (représentant un composant ou une boîte) fait apparaitre un menu popup avec plusieurs options :

\par\ql\{bml NouveauDialogue_Popup_256.bmp\}\par\ql

<bullet.bmp> <u>Aspect</u> : permet d'aligner les contrôles sélectionnés, soit ensemble, soit sur la grille, soit encore dans la fenêtre principale. Certaines de ces options seront grisées si un seul composant est sélectionné, ou bien si c'est la fenêtre principale qui est sélectionnée.

<bullet.bmp> <u>Couper</u> : permet de copier les composants sélectionnés dans le presse-papier, puis de les supprimer.

<bullet.bmp> <u>Copier</u> : permet de copier les composants sélectionnés dans le presse-papier.

<bullet.bmp> <u>Coller</u> : permet de coller les composants du presse-papier sous le noeud sélectionné.

<bullet.bmp> <u>Supprimer</u> : supprime le ou les composant(s) sélectionné(s). Si vous supprimez par erreur un composant, vous pouvez défaire la suppression avec un UNDO (généralement CTRL Z).

<bullet.bmp> <u>Propriétés</u> : Ouvre une boîte de dialogue permettant d'afficher et de modifier les propriété du ou des composants sélectionnés. Si plusieurs composants sont sélectionnés, seuls les composants communs à tous les composants sélectionnés sont affichés. Pour plus de détails, voir <jump=SHM_contents0035>Propriétés d'un contrôle</jump>.

<boxl>Grille d'alignement</box>

La grille permet d'aligner automatiquement les composants sur un multiple entier de pixels. Ca évite d'avoir un ou deux pixels d'écart entre les composants, écart qui ne se voit pas toujours au premier coup d'oeil. Vous pouvez régler l'espacement de la grille en X et en Y.

<boxl>Création d'un composant</box>

Pour créer un nouveau composant, cliquez sur l'icône du composant choisi, puis positionnez-le dans la boîte de dialogue en tenant le bouton gauche de la souris enfoncée. Le sens de saisie (gauche-droite et haut-bas) n'a pas d'importance. La fenêtre de propriétés s'ouvre ensuite automatiquement pour saisir les informations complémentaires, comme le nom, les ancrages, etc... Pour plus de détails sur les propriétés des composants, voir <jump=SHM_contents0035>Propriétés d'un contrôle</jump>.

<boxl>Modification d'un composant</box>

Vous pouvez modifier graphiquement les composants, pour changer soit leurs emplacement, soit leurs tailles, soit leurs ancrages. Sélectionnez-le en cliquant dessus ou bien en cliquant sur son nom dans le tree-view. Le composant sélectionné se visualise avec un entourage de couleur. Vous pouvez ensuite le déplacer ou le redimensionner en déplaçant le bord de l'entourage, ou bien le cadre en entier (la forme du curseur vous indique l'action qui va être effectuée). Pour changer l'ancrage, cliquez sur le petit carré symbolisant l'ancrage en tenant la touche CTRL enfoncée. Le carré change de couleur. Vous pouvez déplacer, redimensionner ou modifier plusieurs composants en même temps si plusieurs sont sélectionnés.

Pour modifier les propriétés du composant, faites un clic droit sur le composant. Il apparait le même menu contextuel que dans le tree-view (voir plus haut).
----- SHM ---- page 30 ---- 
Les macro-instructions permettent d'enregistrer une suite de touches ou d'actions du clavier, puis de les rejouer ensuite une ou plusieurs fois.

Lancer la commande "Enregistrer une macro", puis tapez le texte et les commandes que vous souhaitez enregistrer. Lorsque vous avez fini, cliquez sur "Arrêter l'enregistrement" dans le menu. Votre macro est mémorisée. Vous pouvez ensuite l'exécuter autant de fois que vous le souhaitez. Il y a cependant quelques limitations :

<bullet.bmp> Vous ne pouvez pas enregistrer d'actions de la souris.
<bullet.bmp> Vous ne pouvez pas enregistrer les actions clavier dans les boîtes de dialogue (fonction de recherche par exemple). En revanche, les raccourcis clavier fonctionnent, et vous pouvez par exemple utiliser la touche F3 pour chercher l'occurrence suivante.
----- SHM ---- page 31 ---- 
Le programme FVCLIDE peut être lancé par une ligne de commande, par exemple dans un fichier batch ou bien via la fonctionnalité "Envoyer vers" de l'explorateur. Dans ce cas, l'espace de travail n'est pas mémorisé.

La syntaxe est la suivante :

<b>FVCLIDE.exe <i>"Nom du fichier 1"</i> [<i>"Nom du fichier 2"</i>] [<i>"Nom du fichier 3"</i>] ...</b>

----- SHM ---- page 32 ---- 

Les messages d'erreur sont de trois types :

<bullet.bmp> <u>Les messages d'information</u> qui affichent une précision, un message à caractère non indispensable, ...

<bullet.bmp> <u>Les messages d'avertissement</u> qui indiquent une erreur non critique.

<bullet.bmp> <u>Les messages d'erreur</u> qui apparaissent lorsque survient une erreur empêchant le déroulement normal du traitement.

\par\qc\{bmc MessageErreur_256.bmp\}\par\ql

Il est parfois possible, essentiellement sur les messages d'information, de cocher la case "Ne plus afficher ce message". Dans ce cas, la réponse que vous donnerez deviendra définitive pour tous les messages du même type. Il est possible de remettre à zéro une ou plusieurs réponses automatiques dans la partie "Options de l'éditeur" (voir <jump=SHM_contents0012>Le menu options</jump> et <jump=SHM_contents0033>Réponses par défaut</jump>).
----- SHM ---- page 33 ---- 
La fenêtre de recherche et de remplacement permet de chercher un texte dans un ou plusieurs fichiers, et éventuellement de le remplacer par un autre, avec des options permettant de préciser la recherche (recherche en début ou en fin de ligne, dans les chaînes, les commentaires, par exemple).

Les différentes fonctions sont dans des onglets de la fenêtre principale (certaines options ne sont visibles que dans certains onglets):

\par\qc\{bmc SearchAndReplace.bmp\}\par\ql

\par\qc\{bmc SearchAndReplaceFiles.bmp\}\par\ql

<boxl><b>Options de recherche</b></box>

<bullet.bmp> <u>Mot entier</u> : Permet de rechercher un mot isolé dans le texte. Les caractères permettant de faire la différence entre un mot et les séparations dépendent du langage du fichier. Et règle générale les caractères alpha-numériques font partie des mots, pour les caractères accentués, le tiret normal "-" et le tiret bas "_", ça dépend du langage, et tous les autres caractères sont en général considérés comme des caractères de séparation (espaces, tabulations, retours à la ligne, virgules, points, points-virgules, etc...).

<bullet.bmp> <u>Différentier MAJ/min</u> : Si cette option est cochée, la recherche fera la différence entre les caractères minuscules et majuscules.

<bullet.bmp> <u>En début de ligne</u> : La recherche est faite uniquement au début de chaque ligne, après élimination des espaces et tabulations de début de ligne.

<bullet.bmp> <u>En fin de ligne</u> : La recherche est faite uniquement à la fin de chaque ligne, après élimination des espaces et tabulations de fin de ligne.

<bullet.bmp> <u>Uniquement dans les commentaires</u> : La recherche est faite uniquement dans les commentaires. Le marqueur des commentaires dépend du langage du fichier.

<bullet.bmp> <u>Uniquement hors des commentaires</u> : La recherche est faite uniquement en dehors des commentaires. Le marqueur des commentaires dépend du langage du fichier.

<bullet.bmp> <u>Uniquement dans les guillements</u> : La recherche est faite uniquement dans les chaînes de caractères. Le délimiteur de chaînes dépend du langage du fichier (en général les guillemets).

<bullet.bmp> <u>Uniquement hors des guillements</u> : La recherche est faite uniquement en dehors des chaînes de caractères. Le délimiteur de chaînes dépend du langage du fichier (en général les guillemets).

<bullet.bmp> <u>Expression régulière</u> : La chaîne de recherche est une expression régulière et la recherche est faite en fonction de cela.

<boxl><b>Direction</b></box>

<bullet.bmp> <u>Vers le haut</u> : La recherche se fait vers le début du fichier, de bas en haut.

<bullet.bmp> <u>Vers le bas</u> : La recherche se fait vers la fin du fichier, de haut en bas.

<boxl><b>Origine</b></box>

<bullet.bmp> <u>Depuis le début</u> : La recherche démarre au début du fichier (ou à la fin du fichier si la direction est "vers le haut").

<bullet.bmp> <u>A partir du curseur</u> : La recherche se fait à partir de la position du curseur texte.

<bullet.bmp> <u>Boucler en fin de fichier</u> : Lorsque le programme arrive en fin de fichier (en début de fichier si option "vers le haut"), la recherche se continue au début du fichier (à la fin si option "vers le haut").

<boxl><b>Portée</b></box>

<bullet.bmp> <u>Dans tout le texte</u> : La recherche se fait dans l'intégralité du fichier.

<bullet.bmp> <u>Dans le texte sélectionné</u> : La recherche se fait uniquement dans le texte sélectionné.

<boxl><b>Chercher dans</b></box>

<bullet.bmp> <u>Fichiers du projet</u> : La recherche se fait dans tous les fichiers du projet.

<bullet.bmp> <u>Fichiers de tous les projets</u> : La recherche se fait dans tous les fichiers de tous les projets (c'est à dire dans l'espace de travail).

<bullet.bmp> <u>Fichiers ouverts</u> : La recherche se fait dans tous les fichiers ouverts.

<bullet.bmp> <u>Répertoire</u> : La recherche se fait dans les fichiers d'un répertoire, et éventuellement ses sous-répertoires (voir option ci-dessous)

<bullet.bmp> <u>Sous-répertoires</u> : Si cette case est cochée, la recherche se fait dans tous les sous-répertoires, et récursivement dans les sous-répertoires des sous-répertoires.

<bullet.bmp> <u>Répertoire</u> : Indiquer le répertoire dans lequel chercher les fichiers. Un bouton permet de parcourir l'arborescence des fichiers pour choisir un répertoire.

<bullet.bmp> <u>Extensions</u> : Indiquer l'extension des fichiers dans lesquels effectuer la recherche. Vous pouvez indiquer plusieurs extensions séparées par un point-virgule, ou bien laisser vide pour parcourir tous les fichiers. Par exemple :
<b>*.c;*.cpp;*.h;</b>

<boxl><b>Boutons</b></box>

<bullet.bmp> <u>Chercher</u> ou  <u>Suivant</u> : Lance ou continue la recherche. Le curseur texte se positionne sur l'occurrence suivante trouvée.

<bullet.bmp> <u>Remplacer</u> : Remplace l'occurrence sélectionnée. Ce bouton est grisé si aucune occurrence n'est encore sélectionnée (Il faut alors commencer par faire "Chercher").

<bullet.bmp> <u>Tout</u> : Cherche ou remplace la chaîne définie dans tout le fichier. Les occurrences trouvées s'affichent dans l'onglet "Recherche" de la fenêtre de résultat. Vous pourrez ensuite positionner le curseur dessus en faisant un double-clic sur une ligne.
----- SHM ---- page 34 ---- 
Il arrive souvent qu'on ait à saisir des bouts de code qui, sans être tout à fait identiques, ont de nombreuses ressemblances. Les modèles de code permettent de saisir rapidemment ces parties de code, qui autrement auraient dû être entrées à l'aide de nombreux copiés-collés.
On saisit le modèle dans un petit éditeur. Les parties fixes sont tapées telles quelles, les "variables" sont saisies entre triples accolades. Le nom de la variable peut être librement choisie (espaces et accents autorisés). Voici par exemple le modèle de code permettant de faire une simple boucle <color=10><b>for</b></color>:

\par\qc\{bmc ModèleDeCode_Modification_256.bmp\}\par\ql

Au moment de taper le modèle de code dans le texte, l'éditeur regroupe les noms de variables identiques, et demande à l'utilisateur de remplir leur contenu (le texte à gauche correspond au nom de la variable qui était entre accolades) :

\par\qc\{bmc ModèleDeCode_SaisieParams.bmp\}\par\ql

Puis le programme remplace les variables par leur valeur, et insère le texte à la position du curseur, comme si le texte était tapé au clavier:

\par\qc\{bmc ModèleDeCode_CodeGénéré_256.bmp\}\par\ql
----- SHM ---- page 35 ---- 
L'outil de statistiques permet de compter le nombre de lignes de code, les lignes vides, le nombre de caractères, etc... Le traitement se fait sur plusieurs fichiers, qui peuvent être soit les fichiers ouverts, soit les fichiers du projet, soit encore un répertoire et éventuellement ses sous-répertoires. Le résultat du traitement s'affiche ensuite dans la boîte d'édition en dessous:

\par\qc\{bmc Statistiques_FenêtrePrincipale_256.bmp\}\par\ql

Il est possible de cocher la case "Cumuler les résultats" pour faire plusieurs statistiques successives sans remise à zéro.
----- SHM ---- page 36 ---- 
\par\ql\{bml Conversion_nombres_256.bmp\}\par\ql

Cette fenêtre permet d'obtenir la conversion de nombres au format décimal, hexadécimal, chaîne, nombre réel, signé ou pas. Vous pouvez faire une rotation circulaire bit à bit vers la gauche ou la droite, ou une inversion octet par octet (pour transformer les formats "big endian" en "little endian" et réciproquement).

Les nombres sont juste affichés et convertis. Vous pouvez ensuite faire un copié-collé pour les mettre dans votre programme.
----- SHM ---- page 37 ---- 
Cette fenêtre permet de paramétrer vos outils personnalisés, c'est à dire des programmes externes que vous pourrez ensuite appeler directement depuis le menu de l'application.

\par\qc\{bmc OutilsUtilisateur_Liste_256.bmp\}\par\ql

Pour ajouter un nouvel outil, cliquez sur le bouton "Ajout". Une nouvelle boîte de dialogue s'ouvre :

\par\qc\{bmc OutilsUtilisateur_Ajout_256.bmp\}\par\ql

Il est possible de paramétrer le nom, le programme lui-même, les arguments d'appel, et le répertoire d'exécution.

<bullet.bmp> <u>Nom</u> : Nom qui apparaitra dans le menu

<bullet.bmp> <u>Programme</u> : Chemin complet du programme qui sera lancé

<bullet.bmp> <u>Arguments d'appel</u> : Argument du programme

<bullet.bmp> <u>Répertoire d'exécution</u> : Répertoire dans lequel sera lancé le programme.

Ces outils apparaitront ensuite dans ce même menu, sous la barre de séparation :

\par\qc\{bmc OutilsUtilisateur_Menu_256.bmp\}\par\ql
----- SHM ---- page 38 ---- 
Ces options déterminent le comportement de l'éditeur en général.

<onestep.bmp> <b>Nombre d'espaces des tabulations</b>

Ce nombre définit le nombre d'espaces correspondants à une tabulation. Ce nombre intervient lorsque vous tapez sur la touche tabulation, ou bien lorsque vous transformez les espaces en tabulations ou réciproquement. Soyez prudents lorsque vous modifiez cette valeur, les fichiers qui contiennent à la fois des espaces et des tabulations risquent de voir leur indentation totalement désorganisée.

<onestep.bmp> <b>Transformation des espaces en tabulations</b>

Cette option permet de transformer automatiquement les espaces en tabulations lorsque vous tapez du texte. Elle permet d'éviter une perte de l'indentation si vous changez le nombre d'espaces des tabulations (ou bien si vous changez d'éditeur de texte).

<onestep.bmp> <b>Transformation des tabulations en espaces</b>

Cette option fait l'inverse de la précédente, pour les mêmes raisons. A vous de choisir sous quelle forme vous souhaitez stocker les fichiers: avec uniquement des tabulations (mais certains éditeurs ou comparateurs de fichiers peuvent être perturbés par ces tabulations), ou bien avec uniquement des espaces (mais dans ce cas le nombre d'espaces des indentations est figé).

Cette option est incompatible avec la précédente. Sachez également que dans l'éditeur Free-VCL il existe des fonctions qui permettent de transformer après-coup les espaces en tabulations ou inversement (voir <jump=SHM_contents0007>Fonctions d'édition</jump>).

\par\qc\{bmc EdiOptions_256.bmp\}\par\ql

<onestep.bmp> <b>Afficher les numéros de ligne</b>

Vous pouvez afficher ou pas les numéros de ligne à gauche de la fenêtre d'édition. Cette option ne s'applique pas à l'affichage des fichiers binaires.

<onestep.bmp> <b>Afficher les icônes d'état</b>

Les icônes d'état (marque-pages, points d'arrêt, ou instruction courante se mettent dans une colonne à droite des numéros de ligne. Vous avez le choix d'afficher cette colonne ou pas.

<onestep.bmp> <b>Fermeture automatique des parenthèses</b>

Cette option ajoute automatiquement une parenthèse fermante lorsque vous en ouvrez une, ou bien une accolade fermante lorsque vous en ouvrez une. Ceci vous évite donc de les taper.

<onestep.bmp> <b>Onglets sur plusieurs lignes</b>

\par\qc\{bmc Onglets_Multiline_256.bmp\}\par\ql


\par\qc\{bmc Onglets_Monoline_256.bmp\}\par\ql

Lorsque le nombre d'onglets correspondants aux fichiers ouverts dépasse la largeur de la fenêtre d'édition, les onglets peuvent soit se mettre sur plusieurs lignes, soit se mettre sur une seule ligne avec un bouton de défilement. Cette option permet de choisir entre ces deux possibilités.

----- SHM ---- page 39 ---- 
La fenêtre des raccourcis vous permet de définir des racourcis clavier pour chaque commande de l'éditeur. La partie gauche de la fenêtre reproduit les commandes du menu, avec la même arborescence. Faites un double-clic sur une ligne pour l'ajouter dans la liste des raccourcis. Ensuite, définissez le raccourci lui-même qui peut être saisi de différentes manières:

\par\qc\{bmc Raccourcis_FenêtrePrincipale_256.bmp\}\par\ql

<bullet.bmp> Soit en choisissant une touche dans la liste et en cliquant les touches ALT, SHIFT et CTRL correspondantes au raccourci.
<bullet.bmp> Soit en positionnant le curseur dans la boîte de saisie du raccourci, et en tapant le raccourci directement au clavier.
<bullet.bmp> Il est également possible de définir des raccourcis pré-définis (bouton "Valeurs par défaut") .

Les raccourcis spécifiques à l'éditeur (flèches de direction, coupé, copié, collé, etc...) ne peuvent ni être modifiés ni être utilisés pour lancer d'autres commandes.
----- SHM ---- page 40 ---- 
Vous pouvez personnaliser les couleurs du texte dans l'éditeur. Pour chaque catégorie de texte (texte normal, commentaires, chaînes, nombres, etc...), choisissez dans les listes la couleur du texte et la couleur du fond, et le style de caractères (gras ou incliné). Il est également possible de choisir un style pré-défini dans la liste.
La liste des langages vous permet de visualiser le style avec les différents langages disponibles (pour certains, il se peut que les couleurs ne soient pas toutes utiles).

\par\qc\{bmc Coloration_FenêtrePrincipale_256.bmp\}\par\ql

----- SHM ---- page 41 ---- 
\par\qc\{bmc PoliceCaractères_Saisie_256.bmp\}\par\ql

Cette boîte de dialogue permet de choisir le style et la hauteur des caractères utilisée pour afficher le texte. Vous devez choisir une police de caractères à largeur fixe des caractères. Le programme ne liste que les polices à espacement fixe, mais certaines polices définies comme fixes ont quant même parfois une largeur variable (notamment lorqu'on mélange les caractères gras et non gras). C'est le cas de la police "Courier", par exemple (Utilisez plutôt "Courier New").
----- SHM ---- page 42 ---- 
Ces options s'appliquent à la fonction de formatage automatique du code du menu "outils" (voir <jump=SHM_contents0011>Le menu outils</jump>).

\par\qc\{bmc FormatageCode_Paramètres_256.bmp\}\par\ql

<onestep.bmp> <b>Accolades en fin de ligne</b>

Si cette option est cochée, les accolades ouvrantes seront en fin de ligne. Sinon, elles seront en début de ligne suivante. Cette option n'a aucun effet sur les codes sources en PASCAL ou BASIC, car dans ces langages le mot-clé <color=10><b>then</b></color> est obligatoirement en fin de ligne lorsqu'il débute un bloc d'instructions.

<onestep.bmp> <b>Espaces après parenthèses</b>

Permet d'insérer automatiquement un espace après chaque parenthèse ouvrante, et avant chaque parenthèse fermante. Si la parenthèse est vide, elle ne contiendra qu'un seul espace.

<onestep.bmp> <b>Langage</b>

Permet de choisir le langage de l'exemple affiché, pour pouvoir voir en temps réel les effets des modifications. L'option choisie n'est pas mémorisée.
----- SHM ---- page 43 ---- 
Lorsque vous cochez la case "Ne plus afficher ce message" dans un message d'erreur (voir <jump=SHM_contents0022>Messages d'information et d'erreur</jump>), les réponses automatiques sont mémorisées dans la base de registre. Vous pouvez effacer une ou toutes les réponses par défaut à l'aide de cette boîte de dialogue :

\par\qc\{bmc RéponsesDéfaut_Général_256.bmp\}\par\ql

Cliquez sur une réponse puis sur le bouton "Supprimer" pour effacer une réponse, ou sur "Mise à zéro" pour toutes les supprimer.
----- SHM ---- page 44 ---- 

Cette boîte de dialogue vous permet de créer une nouvelle fenêtre de dialogue :

\par\qc\{bmc NouveauDialogue_Creation_256.bmp\}\par\ql

Vous pouvez créer une nouvelle fenêtre :

<bullet.bmp> complètement vide.

<bullet.bmp> avec juste les boutons "Ok", "Annuler" et "Aide" positionnés en bas.

<bullet.bmp> à partir d'une structure que vous souhaitez renseigner. Mettez votre structure dans la partie "Informations complémentaires". Le programme créera automatiquement une fenêtre permettant la saisie de cette structure.

<bullet.bmp> à partir d'une fenêtre existante (c'est à dire ouverte au moment où vous la créerez). Dans ce cas, choisissez une fenêtre dans la liste qui apparait en dessous. Le programme crée alors une nouvelle fenêtre qui ressemblera autant que faire se peut à la fenêtre que vous aurez choisi.
----- SHM ---- page 45 ---- 
Cette fenêtre permet de saisir les propriétés des contrôles. Le plus souvent, il s'agit de composants (sous-entendu graphiques). Aussi, dans la suite on parlera généralement de composants, même si le terme n'est pas totalement exact.

Cette boîte possède généralement trois onglets, que nous allons détailler ci-dessous :

<boxl><b>Nom et position</b></box>

Cet onglet regroupe les principales informations d'un contrôle :

<bullet.bmp> <u>Nom</u> : c'est le nom qui apparaitra dans le tree-view. Il correspond à la propriété "Name". Bien que ce ne soit pas conseillé, vous pouvez y mettre des espaces et des accents.

<bullet.bmp> <u>Point supérieur gauche</u> : coordonnées du point supérieur gauche du composant.

<bullet.bmp> <u>Point inférieur droit</u> : coordonnées du point inférieur droit du composant. Le fait de changer ces valeurs change la largeur et la hauteur.

<bullet.bmp> <u>Dimensions</u> : largeur et hauteur du composant. Le fait de changer ces valeurs change les coordonnées du point inférieur droit

<bullet.bmp> <u>Coordonnées relatives ou absolues</u> : les coordonnées sont soit absolues (exprimées en pixels par rapport à la zone client du composant parent), soit relatives aux points d'ancrages (par rapport au bord droit ou gauche, puis au bord supérieur ou inférieur, suivant les ancrages du composant. Cette option ne change que l'affichage pour éviter des calculs fastidieux, dans le fichier les coordonnées sont toujours enregistrées en absolu.

<bullet.bmp> <u>Aligner sur l'objet parent</u> : ce bouton permet d'aligner automatiquement le composant sur l'objet auquel il appartient. Cette action ne fait que changer les coordonnées, il ne faut pas la confondre avec la propriété <b>Align</b> des composants.

Si le contrôle n'est pas un composant graphique, les coordonnées ne sont utiles que pendant la construction (pour positionner l'icône).

<boxl><b>Ancrages</b></box>

Cet onglet permet de modifier les ancrages, c'est à dire le comportement du composant lorsqu'on redimensionne le composant parent auquel il appartient : le composant peut se redimensionner ou se déplacer avec le bord droit ou inférieur de la fenêtre, par exemple.

Cliquez sur les carrés symbolisant les ancrages, ou bien choisissez un des ancrages pré-définis dans la partie droite.

<boxl><b>Propriétés</b></box>

Les propriétés sont variables suivant les composants. On retrouve souvent les propriétés "Caption", "Width", "Height", "Visible". Consultez l'aide de chaque élément pour plus de détails sur un composant (voir <jump=SHM_contents0013>Le menu aide</jump>, ou bien l'{\uldb aide en ligne}{\v !ExecFile(www.freevcl.fr/help,,,)} sur internet.
----- SHM ---- page 46 ---- 
<u><b>Migration tool VCL2FreeVCL</b></u>

<b>VCL2FreeVCL</b> tool helps you to transform VCL programs to FreeVCL programs. It process automatically the little syntax differences, i.e. :

<onestep.bmp> Transform of <color=10><b>#include <vcl.h></b></color> to <color=10><b>#include <FreeVCL.h></b></color>.

<onestep.bmp> Transform of <color=10><b>__fastcall</b></color> to <b>FASTCALL</b>.

<onestep.bmp> Deletion of Builder specific keywords <color=10><b>__published</b></color>, <color=10><b>#pragma hdrstop</b></color> and <color=10><b>#pragma package</b></color>.

<onestep.bmp> Add of macros <b>FVCL_BEGIN_COMPONENTS</b> / <b>FVCL_END_COMPONENTS</b> and <b>FVCL_BEGIN_EVENTS</b> / <b>FVCL_END_EVENTS</b>.

<onestep.bmp> Order of components  matching with the DFM.

<onestep.bmp> Add of CallEvent method.

<onestep.bmp> Automatic creation of RC if it doesn't exists.

<onestep.bmp> Eventually, add of macro _T( ).

All source files (.cpp, .h) of choosen path (and subfolders if you have checked the check-box) are transformed. Old files are renamed in .old (.cpp.old and .h.old).

"Unicode strings" option allow you to add automatically the _T( ) macro to all your strings. It is advised to leave this option checked because it will avoid a later process, even if you don't wish to transform now your project to unicode (macro have no effect if the option UNICODE is not activated in your project). See <jump=SHM_contents0006>Unicode</jump> for more details.


<u><b>Then you will have to transform the following things:</b></u>

<onestep.bmp> Adding the keyword <color=10><b>const</b></color> when it is useful.

<onestep.bmp> Changing constructor prototype of TForm.

<onestep.bmp> Some littles improvements to do in WinMain of main project: <color=10><b>new</b></color> and <color=10><b>delete</b></color> of main window, for example (See <jump=SHM_contents0003>My first program</jump>).

The tool sets a comment at places where a manual process should be done, like this:
<color=7><b>//! @todo [VCL2FreeVCL] ...</b></color>

----- SHM ---- page 47 ---- 
<boxl><b>Include path</b></box>

In main menu, choose "Tools", and "Options". Then, in the dialog box below, choose tab "Directories", select "Include Files" in the list-box, and click on "New" icon. Enter the path of .h files, and click on button "Ok".

\par\qc\{bmc Config_Include_V6_16.bmp\}\par\ql

<boxl><b>Lib path</b></box>

Same thing for the path of .lib.

\par\qc\{bmc Config_Lib_V6_16.bmp\}\par\ql

----- SHM ---- page 48 ---- 
<boxl><b>Include path</b></box>

In main menu, choose "Tools", and "Options". Then, in the dialog box below, choose "VC++ Directories" in the tree-view, select "Include Files" in the list-box, and click on "New" button. Enter the path of .h files, and click on button "Ok".

\par\qc\{bmc Config_Include_VE_16.bmp\}\par\ql

<boxl><b>Lib path</b></box>

Same thing for the path of .lib.

\par\qc\{bmc Config_Lib_VE_16.bmp\}\par\ql


----- SHM ---- page 49 ---- 
<boxl><b>Include path</b></box>

In main menu, choose "Settings", and "Compiler and debugger". Then, in the dialog box below, choose "Global compiler settings" in the left panel, select "Search directories" tab and "Compiler", then click on "Add" button. Enter the path of .h files, and click on button "Ok".

\par\qc\{bmc Config_Include_CB_256.bmp\}\par\ql
----- SHM ---- page 50 ---- 
<b><u>Why my dialog boxes don't have the size I have defined in DFM file ?</u></b>

Dialog boxes size is depending on Windows theme. Effectively, depending on the theme, the title bar size and border size can change. If we would keep the size defined in DFM file, the client rectangle would be increased or decreased according to display parameters, and it would be difficult to position components inside. So the dialog boxes size is defined for a standard configuration ("Windows classic" theme) in DFM file, and is inflated or defated in aim to have a client rectangle independant of theme.
----- SHM ---- page 51 ---- 
<boxc><b>compilation error</b></box>

<b><u>"Error: 'struct _dp_Getxxxx_Setxxxx' has no members ..."</u></b>

See <jump=SHM_contents0009>Known problems</jump>


<b><u>"Error: Non-lvalue in assignment"</u></b>

See <jump=SHM_contents0009>Known problems</jump>


<boxc><b>Windows CE</b></box>

<b><u>Error message "Cannot find the program (...) or one of its components"</u></b>

You likely have a Windows CE 3.0 system or older. Windows CE libraries have been compiled with Embedded Visual C .Net, so compatibles with Windows CE 4 ou 5 at least.


<b><u>Error message "This program is not a valid Windows CE application"</u></b>

You have perhaps compiled the program for a platform different of your system. In Embedded Visual C, you have to select (in the combo-box at top right of the window) the type of target system (processor type, essentially).

----- SHM ---- page 52 ---- 
Here is an history of Free VCL versions and its upgrades:

<b><u>Free VCL 1.1.1.1</u></b>

Beta-version

<b><u>Free VCL 1.1.1.2</u></b>

Lot of bugs fixed

<b><u>Free VCL 1.1.2.1</u></b>

Windows CE compatibility
Unicode compatibility
Class TTreeView implemented
Class TListView improved
Components FreeVCL_XFile (allow to create PDF and DBF files)
Components FreeVCL_Web (TCppWebBrowser and sockets)
New samples
English documentation (this one)

<b><u>Free VCL 1.1.2.2</u></b>

Fix a bug which caused an error "This application is not a valid application" on windows CE.
Lot of bugs in class TCanvas.

<b><u>Free VCL 1.1.3.1</u></b>

The class TCanvas is now inherited of an abstract class  TCustomCanvas.
Added the class TMetafile.
Added a sample of use of an object TMetafile.

<b><u>Free VCL 1.1.4.1</u></b>

Added the class TLink.
Added classes TStream, TMemoryStream, TFileStream.

<b><u>Free VCL 1.1.5.1</u></b>

Added classes TAction ans TColorBox.

<b><u>Free VCL 1.2.1.1</u></b>

Compatibility 64 bits.
Folders reorganised and renamed.
----- SHM ---- page 53 ---- 
I would never have been able to create this software without the following tools:


<boxl><b>Code::Blocks {\uldb http://www.codeblocks.org}{\v !ExecFile(http://www.codeblocks.org,,9,)}</b></box>

Compiler free, which has nothing to envy to other expensive compilers that I am forced to use daily (And that I can't name)

Simple, clear, and evolving through an interface allowing the development of plugins



<boxl><b>Embedded Visual C .Net {\uldb http://www.microsoft.com/downloads/details.aspx}{\v !ExecFile(http://www.microsoft.com/downloads/details.aspx?FamilyId=1DACDB3D-50D1-41B2-A107-FA75AE960856&displaylang=en,,9,)}</b></box>

I must also thank mister Microsoft, which provide this tool for free (even if I think it is for commercial reasons) to develop on Windows CE. Not always easy to use, but it works.



<boxl><b>Inno Setup  {\uldb http://www.innosetup.com}{\v !ExecFile(http://www.innosetup.com,,9,)}</b></box>

Installation Program. Try it is adopt it.



<boxl><b>DOXYGEN  {\uldb http://www.doxygen.org/index.html}{\v !ExecFile(http://www.doxygen.org/index.html,,9,)}</b></box>

Documentation automatic sources. You have nothing more to do for having a doc always up to date.



<boxl><b>Shalom Help Maker  {\uldb http://www.danish-shareware.dk/soft/shelpm}{\v !ExecFile(http://www.danish-shareware.dk/soft/shelpm,,9,)}</b></box>

Help file creation program. The one you're reading. As you can see, there's nothing to blame.



<boxc><b><color=4>And I don't thank my english teatchers who have never reached to learn me a good english, which I speak like a spanish cow.</color></b></box>
