##v##00.4.50
pagenumber=38
linenumber=4221
sellength=0
topline=42
EditHelpFileTitle.Text=Free-VCL
form2.STextForeHeadline.Color=16777215
form2.STextForeText.Color=0
form2.STextBackHeadline.Color=12845056
form2.STextBackText.Color=14876671
form2.STextHeadlineFont.Caption=Arial
form2.STextTextFont.Caption=Arial
form2.sTextFontSizeForHeadline.Caption=12
form2.sTextFontSizeForText.Caption=9
form2.CBoxBold.Checked=1
form2.CBoxNoForeColor.Checked=0
form2.CBoxLanguageID.ItemIndex=0
form2.CBoxCharSet.ItemIndex=0
form2.EditContents.Text=Sommaire
form2.EditFrontpageName.Text=Sommaire
form2.CBoxDontMakeFrontpage.Checked=0
form2.EditLogoPath.Text=FreeVcl.bmp
form2.EditFrontpageButtonCaption.Text=Free VCL
form2.RGroupHorizontalAlignment.ItemIndex=0
form2.RGroupVerticalAlignment.ItemIndex=0
form2.CBoxBlankLineBeforeEachHeading.Checked=1
form2.CBoxMakeFrontPageButton.Checked=0
form2.SpinEditFrontpageIDnumber.Value=9999
form2.CBoxAddAboutMenu.Checked=0
form2.EditAboutMenuCaption.Text=&About this help file...
form2.CBoxPopupPagesForAboutMenu.Tag=-1
form2.EditConstantNameFilePrefix.Text=HLP_
form2.EditConstantNameFileExt.Text=txt
form2.CBoxDontMakeHeadersKeywords.Checked=0
form2.CBoxDontMakeTargetsKeywords.Checked=0
copyToPath=
form5.sTextColor1=0
form5.sTextColor2=9743070
form5.sTextColor3=12386403
form5.sTextColor4=255
form5.sTextColor5=8421376
form5.sTextColor6=8650752
form5.sTextColor7=33280
form5.sTextColor8=32896
form5.sTextColor9=13026246
form5.sTextColor10=16711680
form5.sTextColor11=65280
form5.sTextColor12=8651007
form5.sTextColor13=16777215
form5.sTextColor14=16757429
form5.sTextColor15=9764863
form5.sTextColor16=8421504
form5.sTextComment1=
form5.sTextComment2=
form5.sTextComment3=
form5.sTextComment4=
form5.sTextComment5=
form5.sTextComment6=
form5.sTextComment7=
form5.sTextComment8=
form5.sTextComment9=
form5.sTextComment10=
form5.sTextComment11=
form5.sTextComment12=
form5.sTextComment13=
form5.sTextComment14=
form5.sTextComment15=
form5.sTextComment16=
NumOfPages=53
------------ end of project settings / page settings follow ------------
pageC.pages[0].ImageIndex=-1
pageTitle(0).Text=Introduction
getPageConstantLabel(0).Caption=
getPageContentHeaderLabel(0).Caption=
pageKeywords(0).Text=
pageC.pages[1].ImageIndex=-1
pageTitle(1).Text=Configuration
getPageConstantLabel(1).Caption=
getPageContentHeaderLabel(1).Caption=
pageKeywords(1).Text=RTTI;path;lib;include
pageC.pages[2].ImageIndex=-1
pageTitle(2).Text=Mon premier programme
getPageConstantLabel(2).Caption=
getPageContentHeaderLabel(2).Caption=
pageKeywords(2).Text=Exemple;FVCL_BEGIN_COMPONENTS;FVCL_END_COMPONENTS;FVCL_BEGIN_EVENTS;FVCL_END_EVENTS;FVCL_ARG_SUPP;FASTCALL;__fastcall;
pageC.pages[3].ImageIndex=-1
pageTitle(3).Text=Les propriétés
getPageConstantLabel(3).Caption=
getPageContentHeaderLabel(3).Caption=
pageKeywords(3).Text=DECLARE_PROPERTY;Property
pageC.pages[4].ImageIndex=-1
pageTitle(4).Text=Les évènements
getPageConstantLabel(4).Caption=
getPageContentHeaderLabel(4).Caption=
pageKeywords(4).Text=DECLARE_EVENT;SET_EVENT;SET_EVENT_STR;
pageC.pages[5].ImageIndex=-1
pageTitle(5).Text=Unicode
getPageConstantLabel(5).Caption=
getPageContentHeaderLabel(5).Caption=
pageKeywords(5).Text=_T;CharString;WideString;AnsiString
pageC.pages[6].ImageIndex=-1
pageTitle(6).Text=Création d'un composant
getPageConstantLabel(6).Caption=
getPageContentHeaderLabel(6).Caption=
pageKeywords(6).Text=GetListProperties;GetTypeProperty;GetDefaultProperty;GetProperty;SetProperty
pageC.pages[7].ImageIndex=-1
pageTitle(7).Text=Internationalisation
getPageConstantLabel(7).Caption=
getPageContentHeaderLabel(7).Caption=
pageKeywords(7).Text=English;Translate
pageC.pages[8].ImageIndex=-1
pageTitle(8).Text=Problèmes connus
getPageConstantLabel(8).Caption=
getPageContentHeaderLabel(8).Caption=
pageKeywords(8).Text=Bug
pageC.pages[9].ImageIndex=-1
pageTitle(9).Text=Différences par rapport à C++ Builder
getPageConstantLabel(9).Caption=
getPageContentHeaderLabel(9).Caption=
pageKeywords(9).Text=DIALOG;RC;
pageC.pages[10].ImageIndex=-1
pageTitle(10).Text=Exemples de programmes
getPageConstantLabel(10).Caption=
getPageContentHeaderLabel(10).Caption=
pageKeywords(10).Text=TRichEdit;PDF;TCppWebBrowser;TSocketClient;TSocketServer;
pageC.pages[11].ImageIndex=-1
pageTitle(11).Text=Généralités
getPageConstantLabel(11).Caption=CONTENTS
getPageContentHeaderLabel(11).Caption=
pageKeywords(11).Text=
pageC.pages[12].ImageIndex=-1
pageTitle(12).Text=Le menu principal
getPageConstantLabel(12).Caption=MENU
getPageContentHeaderLabel(12).Caption=
pageKeywords(12).Text=
pageC.pages[13].ImageIndex=-1
pageTitle(13).Text=La fenêtre espace de travail
getPageConstantLabel(13).Caption=PROJECTS_WINDOWS
getPageContentHeaderLabel(13).Caption=
pageKeywords(13).Text=projets
pageC.pages[14].ImageIndex=-1
pageTitle(14).Text=La fenêtre d'édition
getPageConstantLabel(14).Caption=EDIT_WINDOW
getPageContentHeaderLabel(14).Caption=
pageKeywords(14).Text=
pageC.pages[15].ImageIndex=-1
pageTitle(15).Text=La fenêtre de résultats
getPageConstantLabel(15).Caption=RESULTS_WINDOW
getPageContentHeaderLabel(15).Caption=
pageKeywords(15).Text=
pageC.pages[16].ImageIndex=-1
pageTitle(16).Text=Le menu fichiers
getPageConstantLabel(16).Caption=
getPageContentHeaderLabel(16).Caption=
pageKeywords(16).Text=
pageC.pages[17].ImageIndex=-1
pageTitle(17).Text=Le menu édition
getPageConstantLabel(17).Caption=
getPageContentHeaderLabel(17).Caption=
pageKeywords(17).Text=
pageC.pages[18].ImageIndex=-1
pageTitle(18).Text=Le menu recherche
getPageConstantLabel(18).Caption=
getPageContentHeaderLabel(18).Caption=
pageKeywords(18).Text=Recherche;Remplacement
pageC.pages[19].ImageIndex=-1
pageTitle(19).Text=Le menu macros
getPageConstantLabel(19).Caption=
getPageContentHeaderLabel(19).Caption=
pageKeywords(19).Text=
pageC.pages[20].ImageIndex=-1
pageTitle(20).Text=Le menu construction
getPageConstantLabel(20).Caption=
getPageContentHeaderLabel(20).Caption=
pageKeywords(20).Text=Construction;Reconstruire;Fenêtre de sortie;
pageC.pages[21].ImageIndex=-1
pageTitle(21).Text=Le menu outils
getPageConstantLabel(21).Caption=
getPageContentHeaderLabel(21).Caption=
pageKeywords(21).Text=Outils;
pageC.pages[22].ImageIndex=-1
pageTitle(22).Text=Le menu options
getPageConstantLabel(22).Caption=
getPageContentHeaderLabel(22).Caption=
pageKeywords(22).Text=Options;
pageC.pages[23].ImageIndex=-1
pageTitle(23).Text=Le menu aide
getPageConstantLabel(23).Caption=
getPageContentHeaderLabel(23).Caption=
pageKeywords(23).Text=Aide;
pageC.pages[24].ImageIndex=-1
pageTitle(24).Text=Installation et configuration
getPageConstantLabel(24).Caption=
getPageContentHeaderLabel(24).Caption=
pageKeywords(24).Text=Installation;Configuration
pageC.pages[25].ImageIndex=-1
pageTitle(25).Text=Espaces de travail
getPageConstantLabel(25).Caption=WORKSPACES
getPageContentHeaderLabel(25).Caption=
pageKeywords(25).Text=Workspace
pageC.pages[26].ImageIndex=-1
pageTitle(26).Text=Création et modification d'un projet
getPageConstantLabel(26).Caption=MODIFPROJECT
getPageContentHeaderLabel(26).Caption=
pageKeywords(26).Text=Projet
pageC.pages[27].ImageIndex=-1
pageTitle(27).Text=Edition de fichiers
getPageConstantLabel(27).Caption=EDITTEXT
getPageContentHeaderLabel(27).Caption=
pageKeywords(27).Text=Editeur
pageC.pages[28].ImageIndex=-1
pageTitle(28).Text=Les marque-pages
getPageConstantLabel(28).Caption=BOOKMARK
getPageContentHeaderLabel(28).Caption=
pageKeywords(28).Text=Marque-page
pageC.pages[29].ImageIndex=-1
pageTitle(29).Text=Modification d'une fenêtre de dialogue
getPageConstantLabel(29).Caption=SAISIEDIALOG
getPageContentHeaderLabel(29).Caption=
pageKeywords(29).Text=Dialogues;Composants;Contrôles;
pageC.pages[30].ImageIndex=-1
pageTitle(30).Text=Les macros
getPageConstantLabel(30).Caption=MACROS
getPageContentHeaderLabel(30).Caption=
pageKeywords(30).Text=Macros-instructions;
pageC.pages[31].ImageIndex=-1
pageTitle(31).Text=Lancement en ligne de commande
getPageConstantLabel(31).Caption=
getPageContentHeaderLabel(31).Caption=
pageKeywords(31).Text=Ligne de commande;
pageC.pages[32].ImageIndex=-1
pageTitle(32).Text=Messages d'information et d'erreur
getPageConstantLabel(32).Caption=DISPLAYERROR
getPageContentHeaderLabel(32).Caption=
pageKeywords(32).Text=Information;Avertissement;Erreur;
pageC.pages[33].ImageIndex=-1
pageTitle(33).Text=Recherche et remplacement
getPageConstantLabel(33).Caption=SEARCHANDREPLACE
getPageContentHeaderLabel(33).Caption=
pageKeywords(33).Text=Recherche;Remplacement;
pageC.pages[34].ImageIndex=-1
pageTitle(34).Text=Saisie de modèles
getPageConstantLabel(34).Caption=SAISIEMODEL
getPageContentHeaderLabel(34).Caption=
pageKeywords(34).Text=Modèles;
pageC.pages[35].ImageIndex=-1
pageTitle(35).Text=Statistiques
getPageConstantLabel(35).Caption=STATISTICS
getPageContentHeaderLabel(35).Caption=
pageKeywords(35).Text=Nombre de lignes;Nombre de caractères;
pageC.pages[36].ImageIndex=-1
pageTitle(36).Text=Conversion de nombres
getPageConstantLabel(36).Caption=CONVERTNUMBERS
getPageContentHeaderLabel(36).Caption=
pageKeywords(36).Text=Décimal;Hexadécimal;Conversion;Float;Big endian;Little endian;
pageC.pages[37].ImageIndex=-1
pageTitle(37).Text=Outils utilisateurs
getPageConstantLabel(37).Caption=SAISIETOOLS
getPageContentHeaderLabel(37).Caption=
pageKeywords(37).Text=
pageC.pages[38].ImageIndex=-1
pageTitle(38).Text=Options générales de l'éditeur
getPageConstantLabel(38).Caption=EDIOPTIONS
getPageContentHeaderLabel(38).Caption=
pageKeywords(38).Text=Options;Parenthèses;Onglets;
pageC.pages[39].ImageIndex=-1
pageTitle(39).Text=Définition des raccourcis
getPageConstantLabel(39).Caption=SAISIERACC
getPageContentHeaderLabel(39).Caption=
pageKeywords(39).Text=
pageC.pages[40].ImageIndex=-1
pageTitle(40).Text=Coloration syntaxique
getPageConstantLabel(40).Caption=SAISIECOLORS
getPageContentHeaderLabel(40).Caption=
pageKeywords(40).Text=Italique;Gras;Couleur du texte;
pageC.pages[41].ImageIndex=-1
pageTitle(41).Text=Police de caractères
getPageConstantLabel(41).Caption=POLICE_FONT
getPageContentHeaderLabel(41).Caption=
pageKeywords(41).Text=Police;Caractères;Fonte
pageC.pages[42].ImageIndex=-1
pageTitle(42).Text=Paramètres de formatage de code
getPageConstantLabel(42).Caption=CODEFORMATPARAMS
getPageContentHeaderLabel(42).Caption=
pageKeywords(42).Text=Formatage de code;
pageC.pages[43].ImageIndex=-1
pageTitle(43).Text=Réponses par défaut
getPageConstantLabel(43).Caption=DEFAULTRESPONSES
getPageContentHeaderLabel(43).Caption=
pageKeywords(43).Text=Ne plus afficher ce message;Réponses automatiques;
pageC.pages[44].ImageIndex=-1
pageTitle(44).Text=Création d'une nouvelle fenêtre de dialogue
getPageConstantLabel(44).Caption=NEWDIALOG
getPageContentHeaderLabel(44).Caption=
pageKeywords(44).Text=Fenêtre de dialogue;
pageC.pages[45].ImageIndex=-1
pageTitle(45).Text=Propriétés d'un contrôle
getPageConstantLabel(45).Caption=PROPRIETES
getPageContentHeaderLabel(45).Caption=
pageKeywords(45).Text=Propriétés;Anchors;Ancrages;Caption;Width;Height;Dimensions d'un contrôle;Visible;
pageC.pages[46].ImageIndex=-1
pageTitle(46).Text=VCL2FreeVCL
getPageConstantLabel(46).Caption=
getPageContentHeaderLabel(46).Caption=
pageKeywords(46).Text=Migration
pageC.pages[47].ImageIndex=-1
pageTitle(47).Text=Visual Studio 6
getPageConstantLabel(47).Caption=
getPageContentHeaderLabel(47).Caption=
pageKeywords(47).Text=
pageC.pages[48].ImageIndex=-1
pageTitle(48).Text=Visual Studio Express
getPageConstantLabel(48).Caption=
getPageContentHeaderLabel(48).Caption=
pageKeywords(48).Text=
pageC.pages[49].ImageIndex=-1
pageTitle(49).Text=Code::Blocks
getPageConstantLabel(49).Caption=
getPageContentHeaderLabel(49).Caption=
pageKeywords(49).Text=
pageC.pages[50].ImageIndex=-1
pageTitle(50).Text=Foire aux questions
getPageConstantLabel(50).Caption=
getPageContentHeaderLabel(50).Caption=
pageKeywords(50).Text=FAQ;MoveWindow;
pageC.pages[51].ImageIndex=-1
pageTitle(51).Text=Résolution des problèmes
getPageConstantLabel(51).Caption=
getPageContentHeaderLabel(51).Caption=
pageKeywords(51).Text=Problèmes
pageC.pages[52].ImageIndex=-1
pageTitle(52).Text=Historique
getPageConstantLabel(52).Caption=
getPageContentHeaderLabel(52).Caption=
pageKeywords(52).Text=
pageC.pages[53].ImageIndex=-1
pageTitle(53).Text=Remerciements
getPageConstantLabel(53).Caption=
getPageContentHeaderLabel(53).Caption=
pageKeywords(53).Text=Download;Téléchargement
------------ end of page titles / full text of pages follow ------------
----- SHM ---- page 0 ---- 
<boxl><b>Bienvenue</b></box>

Free-VCL est une bibliothèque de composants permettant de créer des IHM (interfaces homme-machine), autrement dit des boîtes de dialogues.

Cette librairie a été créée dans le but d'être compatible avec les composants VCL du logiciel C++ Builder. Une bonne connaissance de ce logiciel et de ses composants est essentielle pour comprendre et utiliser Free-VCL. En particulier, de nombreux élément de l'aide en ligne de C++ Builder ne sont pas reproduits dans cette aide. Veuillez vous reporter à l'aide de ce logiciel si vous désirez des précisions supplémentaires.

L'installation contient également des exemples de programmes. Ils vous permettront de vous familiariser avec le fonctionnement de cette librairie.

Pour fonctionner, ce logiciel a besoin d'un compilateur C++, non fourni dans l'installation. Je l'ai testée avec Visual Studio et Code::block. Pour les autres compilateurs, j'attends votre retour d'expérience.

<b><u>Téléchargement de compilateurs</u></b>: voir <jump=SHM_contents0054>Remerciements</jump>
----- SHM ---- page 1 ---- 
Après avoir installé FreeVCL, vous devrez certainement configurer certaines options de votre compilateur.

<chiclet.bmp> <b>Chemin des headers et le librairies.</b>
Cette configuration dépend de votre compilateur, mais en général il suffit d'indiquer (dans options, ou préférences, par exemple ? ) le chemin des fichier H et des fichiers LIB de FreeVCL. Parfois, c'est dans les options du projet. Comme en plus certains compilateurs ne comprennent pas les chemins relatifs, il se peut que même les programmes d'exemple ne se compilent pas tant que vous n'aurez pas redéfini ces valeurs.

Voir configuration dans <jump=SHM_contents0048>Visual Studio 6</jump>, <jump=SHM_contents0049>Visual Studio Express</jump> ou dans <jump=SHM_contents0050>Code::Blocks</jump>

<chiclet.bmp> <b>Activer RTTI.</b>
La RTTI (Run-time type information) doit être activée pour que les nombreux <b><color=10>dynamic_cast</color></b> de la librairie renvoient des valeurs correctes. En général, c'est dans les options du projet.
----- SHM ---- page 2 ---- 
Nous allons étudier ensemble la création d'un programme minimum qui s'appelle "Bonjour mot" (traduction de "Hello word", le premier qui ricane de mon anglais pourri recevra toute ma collection de virus par pigeon voyageur). Le code complet de ce programme se trouve dans le répertoire "Samples\\BonjourMot".

Ce programme contient une simple fenêtre (on va l'appeler TForm_Principale) avec écrit "Bonjour mot", et un menu avec l'option "quitter".

<boxl><b>BonjourMot.cpp</b></box>

Nous allons créer ce projet dans l'EDI à l'aide de modèles. Dans l'EDI FreeVCL, ouvrez ou créez un workspace puis déclarez-le comme projet courant. Puis, dans le menu "Fichiers", choisissez "Projets" puis "Nouveau". Dans la fenêtre suivante, choisissez l'option "Application FreeVCL" et donnez-lui un nom (ici, le nom est juste celui qui apparaitra dans l'arborescence, pas celui du projet).

\par\qc\{bmc Création_nouveau_projet_16.bmp\}\par\ql

Ensuite, vient la création de l'application elle-même. Donnez-lui un nom, un répertoire de destination, et choisissez "Projet minimal" : 

\par\qc\{bmc Création_nouvelle_application_16.bmp\}\par\ql

On voit ensuite les fichiers créés automatiquement. Il est possible de les visualiser en faisant un double-clic sur le nom (ou clic droit + "Editer le fichier" dans le cas du fichier DFM).

\par\qc\{bmc Création_bonjour_mot_16.bmp\}\par\ql

Le fichier principal du projet est le fichier <b>BonjourMot.cpp</b>. Il contient le point d'entrée Windows <b>WinMain</b>. En général, cette fonction est toujours à peu près la même. Si vous n'avez pas créé le fichier à partir d'un modèle comme ci-dessus, il est possible de faire un copié-collé d'un autre projet :

<b><color=7>//---------------------------------------------------------------------------
// Fonction principale:
//---------------------------------------------------------------------------</color>

<color=10>int</color> PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <color=10>int</color> nCmdShow) \{
  <color=10>int</color> Retour;
  TForm_Principale *Form_Principale;


  <color=10>try</color> \{

    HInstance = hInstance;

    Form_Principale = <color=10>new</color> TForm_Principale(NULL, _T(<color=3>"TForm_Principale"</color>));

    Retour = Application->Run();

    <color=10>delete</color> Form_Principale;

  \}
  <color=10>catch</color> (...) \{

    MessageBox(NULL,
               _T(<color=3>"\\"Bonjour mot\\" a planté avec succès"</color>),
               _T(<color=3>"Erreur exception"</color>),
               MB_OK | MB_ICONSTOP);

    Retour = -1;

  \}

  <color=10>return</color> Retour;
\}</b>

Le fichier inclut les fichiers suivants:

<onestep.bmp> Le fichier qui contient la description des composants Free-VCL:

<b><color=10>#include <FreeVcl.h></color></b>


<onestep.bmp> Et le fichier qui va contenir la description de la fenêtre (on y revient tout de suite) :

<b><color=10>#include "TForm_Principale.h"</color></b>


<boxl><b>TForm_Principale.dfm</b></box>

Ensuite, il faut décrire la fenêtre principale. Ceci est fait dans un fichier ayant l'extension <b>dfm</b>, <b>TForm_Principale.dfm</b> par exemple dans notre cas précis:

<b><color=10>object</color> Form_Principale: TForm_Principale
  Left = <color=6>100</color>
  Top = <color=6>50</color>
  Width = <color=6>300</color>
  Height = <color=6>200</color>
  Constraints.MinWidth = <color=6>300</color>
  Constraints.MinHeight = <color=6>140</color>
  Position = poScreenCenter
  Caption = <color=3>'Bonjour mot'</color>
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = <color=6>-11</color>
  Font.Name = <color=3>'MS Sans Serif'</color>
  Font.Style = []
  Menu = MainMenu
  OldCreateOrder = False
  DesignSize = (
    866
    598)
  PixelsPerInch = <color=6>96</color>
  TextHeight = <color=6>13</color>
  <color=10>object</color> MainMenu: TMainMenu
    Left = <color=6>0</color>
    Top = <color=6>0</color>
    <color=10>object</color> MenuItem_Fichiers: TMenuItem
      Caption = <color=3>'Fichiers'</color>
      <color=10>object</color> MenuItem_Quitter: TMenuItem
        Caption = <color=3>'Quitter'</color>
        OnClick = MenuItem_QuitterClick
      <color=10>end</color>
    <color=10>end</color>
  <color=10>end</color>
  <color=10>object</color> Label_Bonjour: TLabel
    Left = <color=6>0</color>
    Top = <color=6>20</color>
    Width = <color=6>300</color>
    Height = <color=6>20</color>
    Alignment = taCenter
    Anchors = [akLeft, akTop, akRight]
    Caption = <color=3>'Bonjour mot !'</color>
  <color=10>end</color>
  <color=10>object</color> Button_Ok: TButton
    Left = <color=6>110</color>
    Top = <color=6>120</color>
    Width = <color=6>80</color>
    Height = <color=6>21</color>
    Anchors = [akLeft, akBottom]
    Caption = <color=3>'Ok'</color>
    OnClick = Button_OkClick
  <color=10>end</color>
<color=10>end</color>
</b>

Le format est exactement le même que les fichiers de même nom dans C++ Builder. Il est possible de modifier manuellement ce fichier, mais il est plus simple de le modifier via l'interface (double-clic sur le DFM, ou bien menu "fichier" puis "dialogues")

<boxl><b>TForm_Principale.h</b></box>

La classe de la fenêtre principale est décrite comme suit:

<b><color=10>class</color> TForm_Principale : <color=10>public</color> TForm \{
<color=10>private:</color>
<color=10>public:</color>
	FVCL_BEGIN_COMPONENTS
	<color=7>// FVCL automatic code ! Don't modify this section.</color>
	TMenuItem *MenuItem_Quitter;
	TMenuItem *MenuItem_Fichiers;
	TMainMenu *MainMenu;
	TLabel *Label_Hello;
	TButton *Button_Ok;
	FVCL_END_COMPONENTS

	FVCL_BEGIN_EVENTS
	<color=7>// FVCL automatic code ! Don't modify this section.</color>
	<color=10>void</color> FASTCALL MenuItem_QuitterClick(TObject *Sender);
	<color=10>void</color> FASTCALL Button_OkClick(TObject *Sender);

	<color=10>virtual void</color> SetEvent(TEvent *Event, <color=10>const</color> TCHAR *EventCall) {
		SET_EVENT_STR_1(TForm_Principale, TNotifyEvent, OnClick, MenuItem_QuitterClick, TObject*);
		SET_EVENT_STR_1(TForm_Principale, TNotifyEvent, OnClick, Button_OkClick, TObject*);
	}

	FVCL_END_EVENTS

  TForm_Principale(HWND hWndParent, LPCTSTR szName);
  <color=10>virtual</color> ~TForm_Principale(<color=10>void</color>);
\};
</b>

On constate des différences notables par rapport au fichier équivalent de C++ Builder:

<bullet.bmp> Le mot-clé <b><color=10>__published</color></b> n'est pas présent (ce mot-clé est une spécificité Builder et n'est pas portable). Les objets publiés sont dans la section <b><color=10>public</color></b>.
<bullet.bmp> La déclaration des composants est encadrée par les macros <b>FVCL_BEGIN_COMPONENTS</b> et <b>FVCL_END_COMPONENTS</b>. <u><b>Attention</b></u>: Ces composants doivent être dans le même ordre que dans le fichier DFM, dans l'ordre des mots <b>end</b> dans le cas de composants imbriqués (par exemple, ici, le TMenuItem "MenuItem_Fichiers" est après le TMenuItem "MenuItem_Quitter" parce que le mot-clé <b>end</b> correspondant à "MenuItem_Fichiers" est après le mot-clé <b>end</b> correspondant à "MenuItem_Quitter").
<bullet.bmp> Les déclarations des méthodes de traitement des évènements sont encadrées par les macros <b>FVCL_BEGIN_EVENTS</b> et <b>FVCL_END_EVENTS</b>.
<bullet.bmp> la macro <b>FASTCALL</b> est utilisée au lieu du mot-clé <b><color=10>__fastcall</color></b> (là encore pour compatibilité entre compilateurs).
<bullet.bmp> Le prototype du constructeur de la classe est légèrement différent.
<bullet.bmp> les <b><color=10>#pragma</color></b> spécifiques Builder sont absents.

Et il faut bien évidemment inclure le fichier FreeVCL en début de fichier :

<b><color=10>#include <FreeVcl.h></color></b>


<boxl><b>TForm_Principale.cpp</b></box>

Les méthodes sont ensuite implémentées dans le fichier cpp:

<b><color=7>//---------------------------------------------------------------------------</color>
TForm_Principale::TForm_Principale(HWND hWndParent, LPCTSTR szName)
  : TForm(hWndParent, szName, FVCL_ARG_SUPP) \{

\}

<color=7>//---------------------------------------------------------------------------</color>
TForm_Principale::~TForm_Principale(<color=10>void</color>) \{
\}

<color=7>//---------------------------------------------------------------------------</color>
<color=10>void</color> FASTCALL TForm_Principale::MenuItem_QuitterClick(TObject *Sender) \{
  Close();
\}

<color=7>//---------------------------------------------------------------------------</color>
<color=10>void</color> FASTCALL TForm_Principale::Button_OkClick(TObject *Sender) \{
  Close();
\}

<color=7>//---------------------------------------------------------------------------</color>
</b>

Là encore, il y a quelques petites différence par rapport au programme Builder qui ferait la même chose:

<bullet.bmp> Le constructeur de la classe est différent.
<bullet.bmp> FASTCALL au lieu de <b><color=10>__fastcall</color></b>, toujours.

<boxl><b>BonjourMot.rc</b></box>

Enfin, il faut déclarer le fichier DFM dans les ressources. C'est très simple, ça se fait comme suit dans le fichier rc:

<b><color=10>#include "windows.h"</color>

TFORM_PRINCIPALE DFM MOVEABLE PURE   <color=3>"TForm_Principale.dfm"</color>
</b>

<boxl><b>Le projet</b></box>

Les autres fichiers créés automatiquement sont ceux qui décrivent le projet pour les principaux compilateurs, code::blocks et Visual Studio. Pour les autres compilateurs, il vous faut le créer manuellement et y insérer ces cinq sources. Pour créer un projet, ça dépend de votre compilateur, mais en général c'est assez simple. Choisir l'option "Application Win32" (ou quelque chose qui y ressemble), et "créer un projet vide" (pas de stdafx et autres excentricités). Insérer les sources dans le projet, dans les option du link insérez les fichiers suivants:

<b>comdlg32.a</b> ou <b>comdlg32.lib</b> (c'est selon)
<b>comctl32.a</b> ou <b>comctl32.lib</b> (pareil)
<b>FreeVcl.a</b> ou <b>FreeVcl.lib</b> (vous avez compris)

Compilez, lancez le programme, et si tout va bien vous devez voir apparaître la fenêtre suivante:

\par\qc\{bmc screenshot_BonjourMot.bmp\}\par\ql

Voili, voilà. Vous avez réussi votre premier programme en FVCL.

----- SHM ---- page 3 ---- 
Les propriétés permettent à l'utilisateur d'un composant d'affecter ou de lire une valeur comme si c'était un attribut public, mais en fait c'est une fonction qui est effectuée, ce qui permet des traitements qu'un simple attribut ne permettrait pas. Par exemple, l'utilisateur va écrire:
<b>Button->Left = 10;</b>
Mais en fait, cette écriture est équivalente à:
<b>Button->Set_Left(10);</b>
Et dans la méthode <b>Set_Left</b>, le programmeur a prévu un <b>MoveWindow</b> qui fait que le bouton se déplace effectivement suite à cette instruction.

<boxl><b>Déclaration</b></box>

Dans les programmes normaux, il n'est en général pas besoin de déclarer des propriétés. Vous en aurez surtout besoin si vous créez des composants.

Il y a quatre macros-instructions pour déclarer les propriétés, suivant leur nature:

<b><i><u>Propriétés en lecture seule</u></i> :</b>

<b>DECLARE_PROPERTY_GET( base, type, var )</b>

<b><i><u>Propriétés en lecture-écriture</u></i> :</b>

<b>DECLARE_PROPERTY( base, type, var )</b>

<b><i><u>Propriétés en lecture seule d'un tableau</u></i> :</b>

<b>DECLARE_PROPERTY_TAB_GET( base, type, var )</b>

<b><i><u>Propriétés en lecture-écriture d'un tableau</u></i> :</b>

<b>DECLARE_PROPERTY_TAB( base, type, var )</b>

Ces quatre macros ont pour arguments:

<b>base</b> : Nom de la classe dans laquelle est définie la propriété.
<b>type</b> : Type de la propriété
<b>var</b> : Nom de la propriété

<boxl><b>Implémentation</b></box>

Les fonction d'implémentation des propriétés n'ont pas besoin d'être déclarées (elles le sont automatiquement dans la macro <b>DECLARE_PROPERTY</b>). Leur nom est déterminé comme suit:

Fonction servant à lire la propriété: <b>Get_</b> + le nom de la propriété.
Fonction servant à écrire la propriété: <b>Set_</b> + le nom de la propriété.

Par exemple, pour la propriété <b>Left</b>, les prototypes des fonctions sont:

<b><color=10>virtual int</color> Get_Left(<color=10>void</color>);
<color=10>virtual bool</color> Set_Left(<color=10>int</color> NewLeft);
</b>

Autre exemple avec la propriété <b>Selected</b> de l'objet <b>ListBox</b>, qui est une propriété de forme tableau:

<b><color=10>virtual bool</color> Get_Selected(<color=10>int</color> i);
<color=10>virtual bool</color> Set_Selected(<color=10>int</color> i, <color=10>bool</color> NewSelected);
</b>
----- SHM ---- page 4 ---- 
Les évènements servent à faire un traitement spécifique lorsqu'une action donnée est effectuée (L'exemple le plus classique: l'utilisateur clique sur un bouton ou sur un élément du menu).

<boxl><b>Déclaration</b></box>

Comme les propriétés, vous n'aurez en général pas besoin de déclarer des évènements, sauf si vous créez des composants.

La déclaration se fait très simplement avec les macros suivante:

<b>DECLARE_EVENT_1( event, TypeArgument1 );</b>
<b>DECLARE_EVENT_2( event, TypeArgument1, TypeArgument2 );</b>
<b>DECLARE_EVENT_3( event, TypeArgument1, TypeArgument2, TypeArgument3 );</b>
etc...

Exemple:

<b>DECLARE_EVENT_1( OnChange, TObject * );</b>

<boxl><b>Appel de l'évènement</b></box>

L'appel se fait exactement comme sous Builder, de la même façon qu'une méthode:

<b>event ( var1 )</b>
<b>event ( var1, var2 )</b>
<b>event ( var1, var2, var3 )</b>
etc...

<b>event</b>: Nom de l'évènement.
<b>var1, var2, var3, ...</b> : Arguments de la méthode de traitement.

Exemple:

<b>OnChange ( <color=10>this</color>)</b>

<boxl><b>Affectation d'un évènement</b></box>

L'évènement est généralement affecté de manière classique dans le DFM, avec une ligne du genre:

<b>OnChange = ListBoxChange</b>

Où <b>ListBoxChange</b> est le nom de la méthode à appeler.

Cependant, il est quelquefois nécessaire d'affecter un évènement par programme. Dans un fichier CPP, on utilise alors la macro <b>SET_EVENT</b>:

<b>SET_EVENT(objevent, EventType, EventName, classcall, objcall, fnctcall)</b>

<b>objevent</b>: Objet contenant la définition de l'évènement.
<b>EventType</b> : Type de l'évènement.
<b>EventName</b>: Nom de l'évènement.
<b>classcall</b> : Classe de l'objet contenant la méthode de traitement de l'évènement.
<b>objcall</b> : Objet contenant la méthode de traitement de l'évènement.
<b>fnctcall</b> : Nom de la méthode de traitement.

Exemple:

<b>SET_EVENT(ListBox, TNotifyEvent, OnChange, TForm_MyDialog, Form_MyDialog, ListBoxChange);</b>

Cet exemple redirige l'évènement <b>ListBox->OnChange</b> (de type <b>TNotifyEvent</b>) vers la méthode de traitement <b>Form_MyDialog->ListBoxChange</b> (<b>Form_MyDialog</b> étant de type <b>TForm_MyDialog</b>)

<boxl><b>Traitement d'un évènement</b></box>

Tous les évènement appellent la méthode "SetEvent" de l'objet destination, cette méthode est chargée d'appeler la méthode appropriée en fonction d'un argument de type <b><color=10>const</color>TCHAR *</b>. Le prototype est le suivant:

<b><color=10>virtual void</color> SetEvent(TEvent *Event, <color=10>const</color> TCHAR *EventCall)</b>

En général, vous n'avez pas à modifier cette partie, elle est générée automatiquement lorsque vous sauvegardez le fichier DFM. Mais pour information, l'appel de chaque évènement se fait à l'aide d'une macro SET_EVENT_<i>X</i> (où <i>X</i> est le nombre d'arguments) :

<b>SET_EVENT_STR_X(Class, EventType, EventName, FnctName, Type1, Type2, ..., TypeX);</b>

<b>Class</b>: Classe de l'objet contenant la méthode de traitement de l'évènement.
<b>EventType</b> : Type de l'évènement.
<b>EventName</b>: Nom de l'évènement.
<b>FnctName</b> : Nom de la méthode de traitement.
<b>Type1, Type2, ..., TypeX</b> : Arguments de la méthode de traitement de l'évènement.

Exemples :

<b>SET_EVENT_STR_1(TForm_MyForm, TNotifyEvent, OnClick, Button_OkClick, TObject*);</b>

Cette ligne permet de rediriger l'évènement <b>OnClick</b> (de type <b>TNotifyEvent</b>) vers la méthode de traitement de l'évènement  <b>TForm_MyForm::Button_OkClick(TObject* Sender)</b>


<b>SET_EVENT_STR_4(TForm_MyForm, TOnMouseMove, OnMouseMove, MyMethod, TObject *, TShiftState, <color=10>int</color>, <color=10>int</color>);</b>

Cette ligne permet de rediriger l'évènement <b>OnMouseMove</b> (de type <b>TOnMouseMove</b>) vers la méthode de traitement de l'évènement  <b>TForm_MyForm::MyMethod(TObject* Sender, TShiftState ShiftState, <color=10>int</color> X, <color=10>int</color> Y);</b>

----- SHM ---- page 5 ---- 
FreeVCL est totalement compatible avec l'unicode (caractères sur deux octets).

<boxl><b>Passer en unicode</b></box>

Pour ceci, il suffit de définir la variable préprocesseur <b>UNICODE</b>. En général ça se fait dans les options du projet (certains compilateurs le font même gentiment pour vous). Au pire, un simple <color=10><b>#define UNICODE</b></color> en tout début de chaque fichier source devrait faire l'affaire.

<boxl><b>Les chaînes de caractères</b></box>

Lorsque l'unicode est activé, toutes les chaînes littérales doivent également passer en unicode. Il faut ajouter un <b>L</b> devant la chaîne de caractère pour indiquer que c'est de l'unicode:

L<color=3><b>"ButtonClick"</b></color>

 Mais le mieux est d'utiliser la macro <b>_T</b>. Cette macro définit les chaînes en unicode si la variable <b>UNICODE</b> est définie, ou en simple chaîne de <color=10><b>char</b></color> sinon. Ceci permet d'avoir une totale compatibilité entre les différents compilateurs et les différents systèmes:

_T(<color=3><b>"ButtonClick"</b></color>)

<boxl><b>Les AnsiString</b></box>

Les <b>AnsiString</b>, qui sont normalement des chaînes de caractères 8 bits passent automatiquement en unicode si la variable <b>UNICODE</b> est définie. Si vous voulez absolument un type défini (pour écrire dans un fichier, par exemple), utilisez la classe <b>CharString</b> (chaînes de <color=10><b>char</b></color>) ou bien <b>WideString</b> (unicode), dont le type est indépendant des options. L'opérateur = a été redéfini pour ces classes, et permet de passer d'un type à l'autre.

<u>Remarque</u>: Du coup, les <b>AnsiString</b> peuvent contenir bien plus que de l'ANSI. On conserve ce nom uniquement pour la compatibilité.
----- SHM ---- page 6 ---- 
<b><boxl>La classe TFactory</box></b>

La première étape pour créer vos propres composants est de créer un descendant de la classe TFactory. Cette classe est prévue pour créer un composant à partir de son nom. En effet, le nom est la seule information que connait le système. Lorsque FreeVCL traite un fichier DFM pour créer une fenêtre, il lit par exemple la ligne suivante:

<b>object Button_Ok: TButton</b>

Il interroge ensuite tous les descendants de TFactory (qui sont liés par un système de chaînage), jusqu'à ce qu'il en trouve un capable de créer l'objet TButton.

Lorsque vous créez un nouveau composant, ou un groupe de composants, vous devez donc créer une classe dérivée de TFactory. Son nom est par convention <b>TFactory_<i>QuelqueChose</i></b> (où <b><i>QuelqueChose</i></b> est par exemple le nom de votre groupe de composants).

Il vous faudra ensuite implémenter les deux fonctions virtuelles suivantes:

<b><color=10>bool</color> GetListObjectsVirt(TStrings *ListObjects);</b>
<b>TComponent * CreateObjectVirt(TComponent* AOwner, AnsiString asNom);</b>

<onestep.bmp> La première méthode indique la liste des composants que peut créer la classe. En général, elle se contente de faire un <b>Add</b> à la liste <b>ListObjects</b>:
<b>
  ListObjects->Add(_T(<color=3>"TComposant1"</color>));
  ListObjects->Add(_T(<color=3>"TComposant2"</color>));
  ListObjects->Add(_T(<color=3>"TComposant3"</color>));
  <color=7>// etc...</color>

  <color=10>return true</color>;
</b>

<onestep.bmp> La seconde méthode crée réellement le composant. Là encore, c'est généralement pas très compliqué:
<b>
  <color=10>if</color> (asNom == _T(<color=3>"TComposant1"</color>)) <color=10>return new</color> TComposant1(AOwner);
  <color=10>if</color> (asNom == _T(<color=3>"TComposant2"</color>)) <color=10>return new</color> TComposant2(AOwner);
  <color=10>if</color> (asNom == _T(<color=3>"TComposant3"</color>)) <color=10>return new</color> TComposant3(AOwner);
  <color=7>// etc...</color>

  <color=10>return</color> NULL;
</b>

<b><boxl>Le composant lui-même</box></b>

Suivant que votre composant est graphique ou pas, qu'il contient ou pas une fenêtre Windows, qu'il peut ou non déclencher des évènements, il va dériver d'une classe générique comme <b>TComponent</b>, <b>TControl</b>, ou <b>TWinControl</b> ou bien d'un composant plus spécifique comme <b>TButton</b>, <b>TEdit</b>, par exemple. Dans tous les cas, ce sera un descendant direct ou indirect de <b>TComponent</b>. Il doit donc implémenter les fonction virtuelles suivantes:
<b>
  <color=10>virtual void</color> GetListProperties(TStrings *ListProperties);
  <color=10>virtual</color> TYPEPROPERTY GetTypeProperty(AnsiString asProperty, AnsiString *asInfos);
  <color=10>virtual</color> AnsiString GetDefaultProperty(AnsiString asProperty);
  <color=10>virtual</color> AnsiString GetProperty(AnsiString asProperty);
  <color=10>virtual bool</color> SetProperty(AnsiString asProperty, AnsiString asValue, TPersistent *Sender);
</b>

<onestep.bmp> La méthode <b>GetListProperties</b> permet à l'éditeur de propriétés de lister les propriétés de l'objet. L'implémentation de cette méthode doit ressembler à ceci:
<b>
  TClasseParente::GetListProperties(ListProperties);

  ListProperties->Add(_T(<color=3>"AutoExpand"</color>));
  ListProperties->Add(_T(<color=3>"BorderStyle"</color>));
  ListProperties->Add(_T(<color=3>"Canvas"</color>));
</b>

<i><u>Attention</u></i>: avant traitement, appeler la méthode <b>GetListProperties</b> de la classe parente pour qu'elle ajoute à la liste ses propres propriétés. Chaque classe implémente ainsi en cascade cette méthode dans laquelle ellet passe la main à sa classe parente jusqu'à l'objet de base TComponent. De ce fait, ne pas mettre à zéro la liste en début de traitement, car il se peut que cette méthode ait elle-même été appelée par une classe dérivée.

<onestep.bmp> La méthode <b>GetTypeProperties</b> permet à l'éditeur de propriétés d'afficher un choix, une case à cocher, etc..., en fonction du type de la propriété.
----- SHM ---- page 7 ---- 
FreeVCL a été spécialement prévu pour vous faciliter la traduction de vos programmes en différentes langues, chose qui est généralement peu pratique avec la plupart des EDI.


<boxl><b>Nouvelles méthodes de TApplication</b></box>

Ces méthodes ont été ajoutées à la classe TApplication:


<u>Méthode Translate:</u>

<b>AnsiString Translate(AnsiString asInput);</b>

Cette méthode traduit un texte. Elle doit donc être appelée à chaque fois qu'un texte est dépendant de la langue d'affichage.

Exemple:

<b>MessageBox(Handle, Application->Translate(<color=3>"Toto fait du vélo"</color>), Application->Translate(<color=3>"C'est un test"</color>), MB_OK);</b>

<u>Méthode ChooseLanguage:</u>

<b><color=10>bool</color> ChooseLanguage(<color=10>void</color>);</b>

Cette méthode ouvre un menu popup permettant de choisir une langue parmi toutes celles disponibles. Les langues disponibles sont toutes celles pour lesquelle un fichier <b>lng</b> est présent dans le même répertoire que l'application. Cette méthode est généralement insérée dans le traitement d'une action utilisateur, par exemple suite à un clic sur un bouton langue ou une option du menu, ça me semble une bonne idée.

<u>Méthode SetLanguage:</u>

<b><color=10>bool</color> SetLanguage(AnsiString asNewLanguage);</b>

Cette méthode force une langue particulière. Elle est utilisée par la méthode ChooseLanguage, mais elle peut aussi être appelée directement (par exemple s'il y a un bouton pour chaque langue).


<boxl><b>Dans les DFM</b></box>

Tous les libellés visibles des boîtes de dialogues (labels, titre des boutons, etc...) passent par la méthode <b>Translate</b> ce qui permet de les traduire directement lors du chargement.

Quelques propriétés non visibles appellent également automatiquement la méthode Translate. Par exemple la propriété <b>HelpFile</b> est traduite, ce qui permet d'avoir un fichier d'aide différent pour chaque langue.


<boxl><b>Les fichiers LNG</b></box>

Il y a un fichier LNG par langue de traduction. Leur nom est le libellé qui apparaîtra dans le menu popup de choix. Leur contenu est tout simplement en format texte (comme un fichier TXT). La langue de référence est le français: c'est normal, c'est la langue la plus facile à apprendre (La preuve ? Je l'ai apprise sans difficultés à trois ans, alors qu'en vingt ans d'efforts acharnés je ne parle toujours pas anglais). Sur chaque ligne, donc, il y a le texte français et le texte correspondant dans la langue du fichier, les deux libellés sont séparés par le caractère <b>¤</b>. Les nouveaux libellés dont le programme ne trouve pas la traduction sont automatiquement ajoutés en fin de fichier, mais avec le caractère de séparation <b>µ</b>. Il vous suffit donc de rechercher et de traduire chaque ligne contenant ce caractère pour traduire entièrement votre logiciel.


<boxl><b>Comment procéder</b></box>

Il y a plusieurs manières de procéder possible, en voici par exemple une:

<onestep.bmp> Copiez le fichier Translate.dll (présent dans le répertoire <b>redist</b>) dans le même répertoire que votre application.

<onestep.bmp> Insérez l'appel de la méthode ChooseLanguage d'une manière ou d'une autre dans votre logiciel (bouton ou menu, c'est vous qui voyez).

<onestep.bmp> Créez, dans le même répertoire que votre application, un fichier English.lng vide avec le bloc-note ou n'importe quel éditeur. Lancez ensuite votre logiciel, choisissez la langue English, puis exécutez votre programme en ayant soin d'ouvrir toutes les boîtes de dialogues possible.

<onestep.bmp> Fermez votre application, puis éditez à nouveau le fichier LNG. Vous verrez que le programme a automatiquement ajouté les libellés trouvés pendant l'exécution de l'application. Traduisez la seconde partie de chaque ligne et remplacez les caractères <b>µ</b> par des <b>¤</b>. Vous pouvez aussi ajouter manuellement les libellés qui ne l'ont pas été automatiquement (messages d'erreurs, ou autres messages qui n'apparaîssent pas lors du déroulement normal). Vous pourrez de la même manière périodiquement vérifier ensuite que des messages n'ont pas été oubliés, ou ajoutés par l'évolution de votre logiciel.

<onestep.bmp> N'oubliez pas d'intégrer le fichier Translate.dll à votre package d'installation, ainsi que les fichiers lng que vous aurez créé.


<boxl><b>Remarques</b></box>

La langue choisie est mémorisée dans la base de registres, et s'applique ensuite à toutes les applications FreeVCL (à condition bien sûr qu'un fichier langue correspondant soit trouvé).

Le fichier Translate.dll est bien évidemment nécessaire pour la traduction. Mais si votre application n'a pas à être traduite, la dll n'est pas indispensable au fonctionnement du programme. Dans ce cas, vous pouvez donc distribuer votre logiciel sans cette dll.

La traduction étant faite au chargement de la fenêtre, il sera parfois nécessaire de sortir et de revenir dans votre programme pour appliquer un changement de langue.
----- SHM ---- page 8 ---- 
Malgré mes efforts, il subsiste quelques problèmes auquels je n'ai pas trouvé de solution. Si vous avez des idées pour les résoudre, elles sont les bienvenues.

<b><i><u>Problème de compilation avec certaines propriétés:</u></i></b>

Avec le compilateur code-block, certaines syntaxes provoquent des erreurs de compilation. Par exemple:
<b>i = Button->Caption.ToInt();</b>
provoque l'erreur suivante:
Error: 'struct _dp_GetCaption_SetCaption' has no members named 'ToInt'

<u>Contournement du problème</u>:
<onestep.bmp> Il faut effectuer l'opération en deux étapes:
<b>AnsiString asTemp = Button->Caption;
i = asTemp.ToInt();</b>

<onestep.bmp> Ou bien utiliser un cast:
<b>i = ((AnsiString) Button->Caption).ToInt();</b>

<b><i><u>Affectation d'une propriété de type tableau:</u></i></b>

Je n'ai pas réussi à faire une propriété de type tableau en lecture-écriture. Quand on fait "ListBox->Selected[i] = <b><color=10>true</color></b>", le "Selected[i]" est interprété comme un "Get_Selected(i)" (application de l'opérateur []) et ensuite le "=" fait une erreur "Non-lvalue in assignment".

<u>Contournement du problème</u>: il faut utiliser la méthode "Set_..." que j'ai donc mis en <color=10><b>public:</b></color>
<b>ListBox->Set_Selected(i, <color=10>true</color>);</b>

<b><i><u>Lecture des propriétés après la fermeture d'une fenêtre:</u></i></b>

Il est impossible de lire les propriétés d'un contrôle après fermeture de la fenêtre (car les objets GDI sont détruits dès la fermeture). Par exemple, si on fait :

<b>MaFenetre->Show();
MaFenetre->Close();
i = MaFenetre->ListBox->ItemIndex;</b>

L'objet GDI sous-jacent à ListBox est détruit dès la sortie du <b>ShowModal</b>, et <b>ItemIndex</b> renvoie donc un LB_ERR (c'est à dire -1).

<u>Contournement du problème</u>:
<onestep.bmp> Solution 1: Mémoriser les valeurs dans une variable intermédiaire avant la destruction de la fenêtre.
<onestep.bmp> Solution 2: Dans l'évènement <b>OnClose</b>, cacher la fenêtre (<b>Action = caHide</b>), ainsi les contrôles ne sont pas détruits.

<u>A noter</u>: Le problème ne se pose pas lorsqu'on fait un <b>ShowModal</b>, la fenetre étant automatiquement cachée dans le <b>OnClose</b>.

<b><i><u>Evénements lors de la construction d'une fenêtre:</u></i></b>

La fenêtre étant créée dans le constructeur de la classe, les méthodes virtuelles ne sont à ce moment pas encore actives. En particulier la méthode <b>OnEvent</b> qui ventile les évènements. De ce fait, les évènements qui surviennent lors de cette création ne sont pas traités. Par exemple la méthode <b>OnActivate</b>.

<u>Contournement du problème</u>:
Appeler explicitement la méthode de traitement de l'évènement dans le constructeur de la fenêtre.

<b><i><u>Problème d'affectation d'une propriété de type objet:</u></i></b>

Lorsqu'une propriété fait référence à un autre objet, cet objet n'est pas trouvé s'il se trouve après dans l'ordre de création. Par exemple:

<b>object PageControl: TPageControl
  ActivePage = TabSheet1
  ...
  object TabSheet1: TTabSheet</b>

<u>Contournement du problème</u>:
<onestep.bmp> Inverser l'ordre de création des objets dans le DFM.
<onestep.bmp> Ou bien utiliser d'autres propriétés lorsque c'est possible (<b>ActivePageIndex</b> dans l'exemple ci-dessus).
----- SHM ---- page 9 ---- 
La syntaxe et le comportement des objets ont été prévus pour être au maximum compatibles avec C++ Builder. Il y a cependant quelques petites différences, soit parce que ce n'était pas possible de faire autrement, soit dans un but d'amélioration.

En plus des différences signalées dans les pages précédentes, voici une liste (sans doute non exhaustive) de différences et d'amélioration:


<boxl><b>Sur les classes en général</b></box>

<onestep.bmp> FreeVCL étant entièrement programmé en C++, on n'a plus les limitations d'héritages qu'on avait dans C++ Builder (où une classe VCL ne peut hériter d'une classe non VCL que si cette dernière est virtuelle pure et sans attributs... Autant dire vide).

<onestep.bmp> Nouveau composant TTrayIcon pour permettre de mettre une icône dans la zone de notification (à coté de l'horloge).

<onestep.bmp> Les classes TForm et TFrame descendent tous deux de la classe TFormFrame (mise en commun du code d'interprétation des DFM).

<onestep.bmp> TOpenDialog et TSaveDialog descendent tous deux de la classe TOpenSaveDialog (mise en commun des propriétés).

<onestep.bmp> TMenu dérive de TMenuItem (pour mise en commun de la propriété Handle et construction plus simple).

<onestep.bmp> Ajout de la propriété DragAcceptFiles et de l'évènement OnDropFile sur tous les composants TWinControl pour permettre un drag and drop depuis l'explorateur.


<boxl><b>Sur les types chaîne</b></box>

<onestep.bmp> AnsiString (en fait CharString ou WideString selon le flag UNICODE) dérive de std::string ou std::wstring (donc toutes les méthodes de ces dernières sont donc disponibles).

<onestep.bmp> La gestion des erreurs par déclenchement d'exception étant souvent envahissante, ces exceptions ont été supprimées à de nombreux endroits. Par exemple AnsiString.ToInt() ne produit pas d'exception lorsque la chaîne passée en argument n'est pas strictement numérique.

<onestep.bmp> Méthode "Translate" et appel de cette méthode pour tous les libellés de DFM (pour faciliter l'internationalisation).

<onestep.bmp> CaseSensitive est une propriété de TStrings (et pas seulement de TStringList).


<boxl><b>Sur les objets</b></box>

<onestep.bmp> TModalResult est un enum plutôt que des #define (plus sûr au niveau programmation).

<onestep.bmp> TParaAttributes de TRichEdit a des nouvelles propriétés (espacement des caractères, indice ou exposant, ...).

<onestep.bmp> TForm et TFrame peuvent lire des ressources 'DIALOGUE' du RC.

<onestep.bmp> Tous les graphiques ont la méthode LoadFromResourceName (et pas seulement les TBitmaps).

<onestep.bmp> Les évènement OnQueryEndSession et OnEndSession, qui manquent cruellement dans Builder, ont été rajoutées à l'objet TApplication (traitement des messages Windows WM_QUERYENDSESSION et WM_ENDSESSION).

<onestep.bmp> Nouvelle propriété TApplication->ExePath.

<onestep.bmp> Nouvelle propriété RightJustify de TMenuItem pour aligner un menu à droite de la fenêtre.

<onestep.bmp> OnShow et OnHide sont des évènements de toutes les classes héritant de TWinControl (et non uniquement TForm et TTabSheet).


<boxl><b>Interface EDI</b></box>

Des méthodes ont été ajoutées pour faciliter la réalisation d'éditeurs de propriétés. Ces méthodes permettent de lister, de lire et d'écrire les propriétés, mais aussi de créer les objets:

<b><color=10>void</color> GetListObjects(TStrings *ListObjects);</b>
Liste des objets pouvant être créés

<b>TComponent *CreateObject(TComponent* AOwner, AnsiString asNom);</b>
Création d'un objet

<b><color=10>virtual bool</color> GetListProperties(TStrings *ListProperties);</b>
Liste les propriétés publiées.

<b><color=10>virtual</color> TYPEPROPERTY GetTypeProperty(AnsiString asProperty, AnsiString *asInfos);</b>
Lecture du type d'une propriété.

<b><color=10>virtual</color> AnsiString GetDefaultProperty(AnsiString asProperty);</b>
Lecture de la valeur par défaut d'une propriété

<b><color=10>virtual</color> AnsiString GetProperty(AnsiString asProperty);</b>
Lecture de la valeur d'une propriété

<b><color=10>virtual bool</color> SetProperty(AnsiString asProperty, AnsiString asValue, TPersistent *Sender);</b>
Ecriture d'une propriété


Toutes ces méthodes sont décrites en détail dans la doc DOXYGEN.
----- SHM ---- page 10 ---- 
Voici la liste des exemples de programmes fournis dans l'installation. Ces exemples sont installés dans le sous-répertoire "Sample" du répertoire d'installation. Ils contiennent les sources, et les projets au format Visual Studio 6, Code::blocks et lorsque cela est possible, Embedded Visual C. En principe, si votre compilateur est bien configuré (voir <jump=SHM_contents0002>Configuration</jump>), il vous suffit d'ouvrir le projet et de compiler pour obtenir l'exécutable. Cependant, il y a parfois des problèmes avec les chemins relatifs et, selon le répertoire d'installation, il vous faudra peut-être modifier certains chemins (accès aux .lib, notamment).

<b><u>BonjourMot</u></b>

\par\ql\{bml screenshot_BonjourMot.bmp\}\par\ql

Programme minimaliste. Voir toutes les explications <jump=SHM_contents0003>ici</jump>

<b><u>RTFExpert</u></b>

Petit traitement de texte permettant de lire et d'enregistrer des fichiers au format RTF. Ce projet utilise la librairie FreeVCL_RichEdit.

<b><u>TestMetafile</u></b>

Crée un fichier metafile (EMF) contenant une image, quelques textes et graphiques. Ce projet utilise la librairie FreeVCL_XFiles.

<b><u>TestPdf</u></b>

Crée un fichier au format PDF contenant les mêmes éléments que le programme précédent. Ce projet utilise la librairie FreeVCL_XFiles.

<b><u>TestCppWebBrowser</u></b>

Exemple d'utilisation de l'objet TCppWebBrowser (navigateur internet). Ce projet utilise la librairie FreeVCL_Web.

<b><u>TestSocket</u></b>

Exemple d'utilisation des sockets. Il se décompose en deux parties: TestSocketServer et TestSocketClient. Ce projet utilise la librairie FreeVCL_Web.

<b><u>TestWebCam</u></b>

\par\ql\{bml screenshot_testwebcam.bmp\}\par\ql

Exemple d'utilisation de l'objet TWebcam. Visualisation et capture d'une image. Ce projet utilise la librairie FreeVCL_Multimed.
----- SHM ---- page 11 ---- 
<boxl><b>Free-VCL IDE</b></box>

Free-VCL IDE est l'éditeur permettant de construire des projets Free-VCL, mais également toutes sortes de projets n'utilisant pas nécessairement la librairie Free-VCL.

<bullet.bmp> Sa principale fonction est l'édition de fichiers (texte ou binaires) comprenant la coloration syntaxique, la mise en forme automatique, les macro-fonctions, des modèles de code.

<bullet.bmp> L'éditeur comprend aussi un module de construction de boîtes de dialogues très complet, qui permet de lire et d'écrire les fichiers RC et DFM, ce qui permet une conversion d'un format à l'autre. Il permet également de construire une boîte de dialogue à partir de modèles pré-définis, d'une fenêtre existante (quel que soit le logiciel auquel elle appartient), ou d'une structure.

<bullet.bmp> La partie projet permet de construire un projet de façon arborescente, chaque projet ayant ses dépendances, ce qui permet de construire une branche de l'arbre ou sa totalité en fonction du besoin. Chaque branche n'est construite que si toutes ses dépendances ont été construites avec succès.

<boxl><b>Fenêtre principale</b></box>

La fenêtre principale se décompose en quatres parties principales, qui seront détaillées dans les pages suivantes:

\par\ql\{bml Fenêtre_principale_256.bmp\}\par\ql

<chiclet.bmp> <jump=SHM_contents0013>Le menu principal</jump> (1)

<chiclet.bmp> <jump=SHM_contents0014>La fenêtre espace de travail</jump> (2)

<chiclet.bmp> <jump=SHM_contents0015>La fenêtre d'édition</jump> (3)

<chiclet.bmp> <jump=SHM_contents0016>La fenêtre de résultats</jump> (4)

Ces parties sont séparées par des barres de séparation permettant de redimensionner une partie ou une autre en fonction des besoins.

<boxl><b>Fonctionnalités</b></box>

<chiclet.bmp> <jump=SHM_contents0025>Installation et configuration</jump>

<chiclet.bmp> <jump=SHM_contents0026>Espaces de travail</jump>

<chiclet.bmp> <jump=SHM_contents0027>Création et modification d'un projet</jump>

<chiclet.bmp> <jump=SHM_contents0028>Edition de fichiers</jump>

<chiclet.bmp> <jump=SHM_contents0029>Les marque-pages</jump>

<chiclet.bmp> <jump=SHM_contents0030>Modification d'une fenêtre de dialogue</jump>

<chiclet.bmp> <jump=SHM_contents0031>Les macros</jump>

<chiclet.bmp> <jump=SHM_contents0032>Lancement en ligne de commande</jump>

<boxl><b>Autres boîtes de dialogue</b></box>

<chiclet.bmp> <jump=SHM_contents0033>Messages d'information et d'erreur</jump>

<chiclet.bmp> <jump=SHM_contents0034>Recherche et remplacement</jump> 

<chiclet.bmp> <jump=SHM_contents0035>Saisie de modèles</jump>

<chiclet.bmp> <jump=SHM_contents0036>Statistiques</jump>

<chiclet.bmp> <jump=SHM_contents0037>Conversion de nombres</jump>

<chiclet.bmp> <jump=SHM_contents0038>Outils utilisateurs</jump>

<chiclet.bmp> <jump=SHM_contents0039>Options générales de l'éditeur</jump>

<chiclet.bmp> <jump=SHM_contents0040>Définition des raccourcis</jump>

<chiclet.bmp> <jump=SHM_contents0041>Coloration syntaxique</jump>

<chiclet.bmp> <jump=SHM_contents0042>Police de caractères</jump>

<chiclet.bmp> <jump=SHM_contents0043>Paramètres de formatage de code</jump>

<chiclet.bmp> <jump=SHM_contents0044>Réponses par défaut</jump>

<chiclet.bmp> <jump=SHM_contents0045>Création d'une nouvelle fenêtre de dialogue</jump>

<chiclet.bmp> <jump=SHM_contents0046>Propriétés d'un contrôle</jump>
----- SHM ---- page 12 ---- 
\par\ql\{bml Menu_256.bmp\}\par\ql

<boxl><b>Fichiers</b></box>
Ce menu permer d'ouvrir, d'enregistrer et de fermer des fichiers (textes ou binaires), des boîtes de dialogue, des projets ou des espaces de travail. Les fichiers récemment utilisés peuvent être réouverts en un clic. Il est également possible d'ouvrir un fichier en faisant un drag and drop (glissé-déposé) de ce fichier depuis l'explorateur vers la fenêtre d'édition.

Pour plus de détails, voir <jump=SHM_contents0017>Le menu fichiers</jump>

<boxl><b>Edition</b></box>
Ce menu regroupe les fonction d'édition, c'est à dire les fonctions qui agissent sur le texte du fichier ouvert.
Pour plus de détails, voir <jump=SHM_contents0018>Le menu édition</jump>

<boxl><b>Recherche</b></box>
Fonctions de recherche et de remplacement dans des fichiers.
Pour plus de détails, voir <jump=SHM_contents0019>Le menu recherche</jump>

<boxl><b>Macros</b></box>
Rassemble les fonctions facilitant la saisie de code : les macro-instructions et les modèles de code.
Pour plus de détails, voir <jump=SHM_contents0020>Le menu macros</jump>

<boxl><b>Construire</b></box>
Permet de construire et de lancer les projets.
Pour plus de détails, voir <jump=SHM_contents0021>Le menu construction</jump>

<boxl><b>Outils</b></box>
Regroupe toute une série d'outils pouvant servir ponctuellement, plus des outils que vous pouvez définir vous-même.
Pour plus de détails, voir <jump=SHM_contents0022>Le menu outils</jump>

<boxl><b>Options</b></box>
Permet de paramétrer et de personnaliser les options du programme.
Pour plus de détails, voir <jump=SHM_contents0023>Le menu options</jump>

<boxl><b>Aide</b></box>
Permet de consulter les document d'aide et autres informations (version, contact, ...).
Pour plus de détails, voir <jump=SHM_contents0024>Le menu d'aide</jump>
----- SHM ---- page 13 ---- 
\par\ql\{bml Fenêtre_projets_256.bmp\}\par\ql

Cette fenêtre affiche tous les projets de l'espace de travail. Ces projets sont organisés en arborescence, chaque projet pouvant être dépendant d'autres projets. Vous pouvez faire un clic droit sur un projet ou un fichier, un menu contextuel s'ouvrira. Ce menu vous permet de faire des actions particulières sur les projets.

Voir <jump=SHM_contents0026>Espaces de travail</jump>
----- SHM ---- page 14 ---- 
\par\ql\{bml Fenêtre_édition_256.bmp\}\par\ql

La fenêtre d'édition permet d'éditer plusieurs fichiers, chaque fichier se trouvant dans un onglet. Ceux-ci peuvent êtres disposés sur plusieurs lignes ou sur une seule, en fonction des options de l'éditeur (voir <jump=SHM_contents0039>Options de l'éditeur</jump>).

Vous pouvez ouvrir un fichier dans l'éditeur en faisant juste un glissé-déposé (drag and drop) depuis l'explorateur de fichiers dans la fenêtre d'édition. Le programme détectera automatiquement s'il s'agit d'un fichier texte ou d'un fichier binaire.

Pour plus de détails sur l'édition de fichiers, voir <jump=SHM_contents0028>Edition de fichiers</jump>.
----- SHM ---- page 15 ---- 
\par\ql\{bml Fenêtre_résultats_256.bmp\}\par\ql

Cette fenêtre contient plusieurs onglets qui permettent de visualiser les résultats des recherches, les marque-pages ou le résultat d'une compilation. Généralement, lorsque des lignes de fichiers sont affichés (résultat d'une recherche, erreur de compilation, par exemple), vous pouvez faire un double-clic sur cette ligne pour y accéder directement dans l'éditeur. Le fichier concerné est automatiquement ouvert s'il ne l'était pas déjà, et le curseur se positionne sur la ligne. Il est ensuite possible de faire "référence précédente" ou "référence suivante" (dans le menu édition) pour parcourir successivement toutes les références.
----- SHM ---- page 16 ---- 

<boxl><b>Espaces de travail</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder un espace de travail.

Pour plus de détails, voir <jump=SHM_contents0026>Espaces de travail</jump>.

<boxl><b>Projets</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder un projet.

Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.

<boxl><b>Fichiers</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder un fichier texte ou binaire.

Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Dialogues</b></box>
Ce menu permet d'ouvrir, de créer ou de sauvegarder une fenêtre de dialogue.

Pour plus de détails, voir <jump=SHM_contents0045>Création d'une nouvelle fenêtre de dialogue</jump> et <jump=SHM_contents0030>Modification d'une fenêtre de dialogue</jump>.

<boxl><b>Quitter</b></box>
Cette commande permet de quitter le programme. Si vous avez des fichiers modifiés et non sauvegardés, le programme vous proposera de les enregistrer ou d'abandonner vos modifications.

----- SHM ---- page 17 ---- 

<boxl><b>Défaire</b></box>
Défait la dernière opération.
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Refaire</b></box>
Refait la dernière opération défaite.
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Couper</b></box>
Copie le contenu de la sélection dans le presse-papiers, en l'effaçant de l'éditeur.
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Copier</b></box>
Copie le contenu de la sélection dans le presse-papiers, sans modifier la version dans l'éditeur.
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Coller</b></box>
Insère le contenu du presse-papiers à la position du curseur.
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Référence précédente</b></box>
Permet d'afficher la ligne correspondante à la référence précédente dans la fenêtre de résultat.
Pour plus de détails, voir <jump=SHM_contents0016>La fenêtre de résultats</jump>.

<boxl><b>Référence suivante</b></box>
Permet d'afficher la ligne correspondante à la référence suivante dans la fenêtre de résultat.
Pour plus de détails, voir <jump=SHM_contents0016>La fenêtre de résultats</jump>.

<boxl><b>Tout sélectionner</b></box>
Permet de sélectionner tout le contenu de la fenêtre d'édition.
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Aller à la ligne numéro...</b></box>
Permet d'atteindre une ligne précise dans le fichier ouvert. Entrez le numéro de ligne à atteindre.

<boxl><b>Fonctions avancées</b></box>

<u><b>Mettre en minuscules</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<u><b>Mettre en majuscules</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<u><b>Commenter</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<u><b>Décommenter</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Marques-pages</b></box>
Pour plus de détails, voir <jump=SHM_contents0024>Le menu d'aide</jump>

<u><b>Ajouter un marque-page</b></u>
Positionne un marque-page à la position du curseur.
Pour plus de détails, voir <jump=SHM_contents0029>Les marque-pages</jump>.

<u><b>Supprimer un marque-page</b></u>
Supprime le marque-page à la position du curseur.
Pour plus de détails, voir <jump=SHM_contents0029>Les marque-pages</jump>

<u><b>Effacer tous les marque-pages</b></u>
Efface tous les marque-pages.
Pour plus de détails, voir <jump=SHM_contents0029>Les marque-pages</jump>

<boxl><b>Document</b></box>

<u><b>Tabulations -> Espaces</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<u><b>Espaces -> Tabulations</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

<u><b>Supprimer les espaces de fin</b></u>
Pour plus de détails, voir <jump=SHM_contents0028>Edition de fichiers</jump>.

----- SHM ---- page 18 ---- 
<boxl><b>Rechercher</b></box>
Pour plus de détails, voir <jump=SHM_contents0034>Recherche et remplacement</jump>

<boxl><b>Rechercher dans des fichiers</b></box>
Pour plus de détails, voir <jump=SHM_contents0034>Recherche et remplacement</jump>

<boxl><b>Remplacer</b></box>
Pour plus de détails, voir <jump=SHM_contents0034>Recherche et remplacement</jump>

<boxl><b>Remplacer dans des fichiers</b></box>
Pour plus de détails, voir <jump=SHM_contents0034>Recherche et remplacement</jump>

<boxl><b>Rechercher précédent</b></box>
Pour plus de détails, voir <jump=SHM_contents0034>Recherche et remplacement</jump>

<boxl><b>Rechercher suivant</b></box>
Pour plus de détails, voir <jump=SHM_contents0034>Recherche et remplacement</jump>

----- SHM ---- page 19 ---- 
<boxl><b>Enregistrer</b></box>
Enregistre une macro.
Pour plus de détails, voir <jump=SHM_contents0031>Les macros</jump>

<boxl><b>Exécuter</b></box>
Exécute la macro précédemment enregistrée.
Pour plus de détails, voir <jump=SHM_contents0031>Les macros</jump>

<boxl><b>Répéter une macro</b></box>
Exécute la macro un certain nombre de fois, ou bien jusqu'à ce que la fin du fichier soit atteinte, ou bien encore jusqu'au début. Toutes les opérations sont enregistrées comme une seule action, c'est à dire qu'il est possible de la défaire en un seul UNDO (alors que si on avait fait N fois "Exécuter" à la main, on aurait eu N actions enregistrées).

<boxl><b>Modèles de code</b></box>
Définition et application de modèles de code.
Pour plus de détails, voir <jump=SHM_contents0035>Modèles de code</jump>
----- SHM ---- page 20 ---- 
<boxl><b>Construire</b></box>
Lance la construction du projet.
Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.

<boxl><b>Reconstruire</b></box>
Lance la construction complète du projet (sans tenir compte des éléments déjà construits).
Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.

<boxl><b>Construire tout</b></box>
Lance la construction de l'ensemble des projets de l'espace de travail.
Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.

<boxl><b>Reconstruire tout</b></box>
Lance la construction complète de l'ensemble des projets de l'espace de travail.
Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.

<boxl><b>Voir la fenêtre de sortie</b></box>
Affiche le résultat de la construction (onglet "traitements" de la fenêtre de résultat). Vous pouvez retrouver la ligne correspondant à un message en faisant un double-clic sur le message d'erreur).
Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.

<boxl><b>Lancer</b></box>
Lance le fichier résultant de la construction. L'effet de ce lancement est variable suivant le type du projet : par exemple si le projet consiste en une compilation de programme, cette commande lance le programme exécutable.
Pour plus de détails, voir <jump=SHM_contents0027>Création et modification d'un projet</jump>.
----- SHM ---- page 21 ---- 
<boxl><b>Statistiques</b></box>
Permet de compter le nombre de lignes dans un programme ou un projet.
Pour plus de détails, voir <jump=SHM_contents0036>Statistiques</jump>.

<boxl><b>Formatage du code</b></box>
Lance le formatage de code sur le fichier ouvert.
Pour plus de détails, voir <jump=SHM_contents0043>Paramètres de formatage de code</jump> et <jump=SHM_contents0028>Edition de fichiers</jump>.

<boxl><b>Conversion de nombres</b></box>
Fenêtre d'aide à la conversion de nombres sous différents formats.
Pour plus de détails, voir <jump=SHM_contents0037>Conversion de nombres</jump>.

<boxl><b>Outils utilisateur</b></box>
Permet de définir et de lancer des programmes externes définis par l'utilisateur.
Pour plus de détails, voir <jump=SHM_contents0038>Outils utilisateur</jump>.
----- SHM ---- page 22 ---- 
<boxl><b>Langue</b></box>

Permet de choisir la langue du programme. Actuellement, seuls le français et l'anglais sont disponibles. Pour que ce changement de langue soit effectif, il vous faudra sortir du programme.

<boxl><b>Options de l'éditeur</b></box>

<u><b>Options générales</b></u>
Options permettant de configurer l'éditeur lui même (espaces et tabulations, affichage des numéros de ligne, etc...).
Pour plus de détails, voir <jump=SHM_contents0039>Options générales de l'éditeur</jump>.

<u><b>Raccourcis clavier</b></u>
Ouvre une boîte de dialogue permettant de définir les raccourcis clavier.
Pour plus de détails, voir <jump=SHM_contents0040>Définition des raccourcis</jump>.

<u><b>Coloration syntaxique</b></u>
Cette boîte de dialogue permet de définir les couleurs de la fenêtre d'édition.
Pour plus de détails, voir <jump=SHM_contents0041>Coloration syntaxique</jump>.

<u><b>Police de caractères</b></u>
Définition de la police de caractères de la fenêtre d'édition (taille, police, etc...).
Pour plus de détails, voir <jump=SHM_contents0042>Police de caractères</jump>.

<u><b>Paramètres de formatage</b></u>
Permet de définir les paramètres de formatage du code.
Pour plus de détails, voir <jump=SHM_contents0043>Paramètres de formatage de code</jump>.

<u><b>Réponses par défaut</b></u>
Permet d'effacer les réponses par défaut enregistrées lorsque vous cochez la case "Ne plus afficher ce message".
Pour plus de détails, voir <jump=SHM_contents0044>Réponses par défaut</jump>.

----- SHM ---- page 23 ---- 
<boxl><b>Aide Free VCL</b></box>
Affiche l'aide de Free VCL, la philosophie générale, des conseils, comment faire un programme, comment configurer le compilateur, etc....

<boxl><b>Aide de l'éditeur</b></box>
Affiche l'aide spécifique à l'éditeur que vous êtes en train de lire.

<boxl><b>Aide en ligne (syntaxe)</b></box>
Affiche l'aide en ligne liée au langage : syntaxe d'une fonction, propriétés et méthodes d'un objet, etc... Cette aide est contextuelle, c'est à dire que si vous positionnez le curseur sur le nom d'une classe, l'aide s'ouvrira sur la page correspondante à cette classe.

<boxl><b>A propos</b></box>
Affiche les informations de version et les informations légales.

<boxl><b>Me contacter</b></box>
Permet d'envoyer un e-mail au support technique. Cette option utilise votre gestionnaire de message, elle ne marchera pas si vous n'en avez aucun de configuré.
----- SHM ---- page 24 ---- 
Le programme d'installation vous propose un répertoire d'installation (par défaut le répertoire des programmes "Program Files"), et configure automatiquement les options par défaut (raccourcis clavier, options de l'éditeur, ...).

Il crée l'arborescence suivante dans le répertoire choisi :

\par\ql\{bml Installation_TreeView_256.bmp\}\par\ql

<bullet.bmp> <u>Bin</u> : Répertoire contenant les exécutables Free VCL, notamment l'éditeur de fichiers <b>FVCLIDE.exe</b>.

<bullet.bmp> <u>Help</u> : Répertoire des fichiers d'aide (celui que vous êtes en tran de lire, entre autres).

<bullet.bmp> <u>Icons</u> : Répertoire contenant les icônes des composants que vous pouvez isérer dans les boîtes de dialogue.

<bullet.bmp> <u>Include</u> : Répertoire des fichiers header à inclure lorsque vous créez un projet Free VCL.

<bullet.bmp> <u>Lib</u> : Fichiers LIB que vous devez lier à vos programmes Free VCL. Ces fichiers sont classés en fonction du compilateur et des options de compilations que vous utilisez :

	<b>VisualStudio</b> : librairies compatibles Visual Studio.
	<b>CodeBlocks</b> : librairies compatibles Code::Blocks

	<b>MBCS_32bits</b> : Chaînes en Multi-Byte Character Set (sur 1 octet pour les caractères courants) et compilation 32 bits.
	<b>UNICODE_32bits</b> : Chaînes en unicode (sur 2 octets) et compilation 32 bits.
	<b>UNICODE_64bits</b> : Chaînes en unicode (sur 2 octets) et compilation 64 bits.

	<b>Release</b> : Signifie que ces fichiers ne contiennent pas les informations de débuggage.

<bullet.bmp> <u>Models</u> : Contient les fichiers modèles, vous pouvez en rajouter si vous le désirez (voir <jump=SHM_contents0035>Saisie de modèles</jump>).

<bullet.bmp> <u>Plugins</u> : Contient les fichiers DLL (librairies dynamiques) correspondant à chaque plugin.

<bullet.bmp> <u>Redist</u> : Contient les seuls fichiers que vous avez le droit de redistribuer dans vos programmes d'installation.

<bullet.bmp> <u>Samples</u> : Petits programmes d'exemple, dont vous pouvez vous inspirer pour vos développements (ces fichiers ne sont pas sous copyright).

<bullet.bmp> <u>Syntax</u> : Contient les mot-clés et les paramètres d'affichage pour chaque extension de fichier.


----- SHM ---- page 25 ---- 
Un espace de travail est un ensemble de projets. Les projets sont organisés en arborescence dans l'espace de travail, chaque projet pouvant dépendre d'un ou plusieurs autres projets. L'espace de travail est automatiquement sauvegardé lorsque vous quittez le programme, sauf si vous avez lancé le programme avec une ligne de commande.

Un projet a des fichiers d'entrée et un fichier de sortie. A son tour, le fichier de sortie peut servir de fichier d'entrée à un autre projet. C'est grâce à ce mécanisme que le programme détermine les projets à construire.

Lorsque vous donnez l'ordre de construire un projet, le programme regarde avant si tous les projets qui en dépendent sont à jour. S'ils ne sont pas à jour, il lance leur construction de la même façon, récursivement. Si une construction échoue, le traitement s'arrête.

Ensuite, le programme compare la date des fichiers d'entrée à la date du fichier de sortie. Si un des fichiers d'entrée (ou le projet lui-même) est plus récent que le fichier de sortie, ça signifie qu'une modification est intervenue sur ce fichier, ou bien sur un des projets qui crée ce fichier. Le programme reconstruit alors le projet. Sinon, cela signifie qu'il est déjà à jour et que le traitement est terminé.

Vous pouvez ainsi créer toute une chaîne de traitements, le programme déterminera automatiquement les traitements à effectuer dès que vous ferez une modification sur un fichier. Prenons un cas concret classique : vous souhaitez mettre en ligne sur un site web le setup d'installation d'un programme (c'est comme ceci que FreeVCL est mis à disposition, par exemple). Le processus complet nécessite trois traitements successifs:

<onestep.bmp> La compilation des programmes.

<onestep.bmp> La construction du setup d'installation.

<onestep.bmp> La copie de ce setup sur le site via FTP.

Nous aurons donc ces projets organisés comme ceci :

<onestep.bmp> La copie du setup est la dernière étape du processus. Il est donc au niveau supérieur (directement sous le noeud racine).

<onestep.bmp> La construction du setup est nécessaire avant de faire la copie. Il est donc au niveau juste en dessous (noeud enfant du projet "copie")

<onestep.bmp> La compilation de chaque programme est nécessaire avant le setup. Chaque compilation est donc au niveau encore en dessous.

Un clic droit sur un projet fait apparaitre un menu contextuel avec les options suivantes :

\par\qc\{bmc FenêtreProjets_Popup_256.bmp\}\par\ql

<onestep.bmp> <b>Tout développer</b> : développe le noeud et tous ses noeuds enfant, récursivement.

<onestep.bmp> <b>Tout réduire</b> : réduit le noeud et tous ses noeuds enfants.

<onestep.bmp> <b>Ajouter un nouveau projet</b> : Crée un nouveau projet en tant que dépendance du projet sélectionné (c'est à dire comme noeud enfant).

<onestep.bmp> <b>Ajouter un projet existant</b> : Insère un projet existant en tant que dépendance.

<onestep.bmp> <b>Renommer</b> : permet de renommer le projet (le nom affiché dans l'arborescence).

<onestep.bmp> <b>Enlever</b> : supprime le projet. Cette option est grisée si le projet contient des sous-projets.

<onestep.bmp> <b>Modifier</b> : permet de modifier le projet. 

<onestep.bmp> <b>Editer le fichier projet</b> : ouvre le fichier projet comme un fichier texte dans l'éditeur.

<onestep.bmp> <b>Construire ce projet</b> : construit le projet et éventuellement les sous-projets en fonction des dates des fichiers d'entrée et de sortie.

<onestep.bmp> <b>Reconstruire ce projet</b> : reconstruit entièrement le projet et les sous-projets indépendamment des dates des fichiers.

<onestep.bmp> <b>Voir le fichier de sortie</b> : ouvre le fichier de sortie dans l'éditeur.
----- SHM ---- page 26 ---- 
Vous pouvez créer un projet de plusieurs façons différentes : par le menu ou bien en faisant un clic droit sur un projet déjà existant dans l'espace de travail, puis "Ajouter un nouveau projet". Dans tous les cas, le nouveau projet est un noeud enfant (dépendance) du projet sélectionné.

Une boîte de dialogue s'ouvre, dans laquelle vous pouvez entrer le nom et le type du projet. Le nom est celui qui apparaitra dans l'arborescence. Les types de projets listés correspondent aux plug-ins installés (chaque plug-in = un type de projet). Il existe des types de projets pour toutes les actions courantes qu'on peut rencontrer dans un travail informatique : copie, transfert FTP,  construction du setup, etc...

\par\qc\{bmc CreationProjet_Ajout_256.bmp\}\par\ql

La fenêtre qui s'ouvre ensuite dépend du type de projet que vous avez choisi. Par exemple, pour une copie de fichier, il faut entrer le fichier de départ et le fichier destination (voir ci-dessous)

Le programme ajoute automatiquement les fichiers dont dépend le projet. Vous pouvez en ajouter d'autres si nécessaire. La modification d'un de ces fichiers aura pour effet d'entrainer la reconstruction du projet lorsqu'on reconstruira un projet de niveau supérieur ou égal.

<boxl>Commande DOS</box>

Effectue une commande DOS. Entrez la commande et les arguments.

<boxl>Copie de fichier</box>

Fait une simple copie de fichiers d'un fichier source à un fichier destination. Le fichier d'entrée est le fichier source, et le fichier de sortie est le fichier destination.

<boxl>Synchronisation FTP</box>

Ce type de projet permet de synchroniser un répertoire local avec un site distant par FTP. Entrez les informations suivantes :

<bullet.bmp> Sens de transfert :

<bullet.bmp> Répertoire local : Entrez le nom complet du répertoire local.

<bullet.bmp> Répertoire distant : Entrez l'adresse du site FTP.

<bullet.bmp> Mot de passe : Entrez le mot de passe permettant l'accès au site FTP.

<bullet.bmp> Port : Entrez le numéro de port pour l'accès au site (généralement port 21).
----- SHM ---- page 27 ---- 
<boxl>Les raccourcis claviers</box>

Vous pouvez utiliser les raccourcis communs à tous les éditeurs. Sans entrer dans les détails (vous êtes supposés savoir vous servir d'un éditeur), on rappellera juste les plus utiles :

<bullet.bmp> CTRL + X : copie le texte sélectionné dans le presse-papiers et le supprime.
<bullet.bmp> CTRL + C : copie le texte sélectionné dans le presse-papiers sans modification du fichier.
<bullet.bmp> CTRL + V : copie le contenu du presse-papier à la position du curseur.

<bullet.bmp> CTRL + flèche haut : déplacement de la fenêtre vers le haut sans déplacer le curseur.
<bullet.bmp> CTRL + flèche bas : déplacement de la fenêtre vers le bas sans déplacer le curseur.
<bullet.bmp> CTRL + flèche droite : déplacement de mot en mot vers la droite.
<bullet.bmp> CTRL + flèche gauche : déplacement de mot en mot vers la gauche.

Sélection rectangulaire : permet de sélectionner un bloc rectangulaire de texte :

\par\ql\{bml Raccourcis_RectSelect_256.bmp\}\par\ql

Cette sélection peut être faite de deux façons :

<bullet.bmp> Tenir CTRL + ALT enfoncés. Presser le bouton gauche de la souris sur un premier coin du rectangle et le relâcher sur l'autre coin. Relâcher CTRL + ALT.
<bullet.bmp> Tenir SHIFT + ALT enfoncés. Cliquer un premier coin du rectangle (clic gauche de la souris) puis cliquer l'autre coin du rectangle. Relâcher SHIFT + ALT.

Il est ensuite possible de copier, coller, supprimer ou remplacer ce bloc de texte comme n'importe quelle sélection.

<boxl>Menu contextuel</box>

<u>Couper</u> : Coupe le texte sélectionné dans le presse-papiers.

<u>Copier</u> : Copie le texte sélectionné dans le presse-papiers.

<u>Coller</u> : Insère le contenu du presse-papiers à la position du curseur.

<u>Positionner un marque-page</u> : Insère un marque-pages sur la ligne du cuseur.

<u>Positionner un point d'arrêt</u> : Insère un point d'arrêt sur la ligne du curseur.

<u>Sélectionner le bloc</u> : Sélectionne le bloc entier contenant le curseur. Les délimiteurs de blocs dépendent du langage, ça peut être les accolades ouvrantes et fermantes, ou les mots clé <color=10><b>begin</b></color> et <color=10><b>end</b></color>. La sélection gère l'imbrication de blocs et sélectionne toujours un bloc complet (contenant autant de débuts de blocs que de fins).

<u>Sélectionner la parenthèse</u> : Sélectionne la parenthèse contenant le curseur. La sélection gère l'imbrication de parenthèses et sélectionne toujours une parenthèse complète (contenant autant de parenthèses ouvrantes que fermantes).

Si le texte sous le curseur est un nom de fichier, il est possible de l'ouvrir avec un simple clic : 

\par\ql\{bmc TextEditor_RightClick1_256.bmp\}\par\ql

Si le texte sélectionné est un nombre, il est possible de le convertir automatiquement en hexadécimal, ou bien inversement en décimal :

\par\ql\{bmc TextEditor_RightClick2_256.bmp\}\par\ql
----- SHM ---- page 28 ---- 
Les marque-pages permettent de retrouver rapidemment des points précis dans vos programmes et fichiers. Positionnez des marque-pages aux endroits qui vous intéressent. Il sont listés dans un onglet de la fenêtre de résultat.

Il y a plusieurs façons de positionner un marque-page : vous pouvez faire un clic droit sur la ligne et sélectionner "positionner un marque-page", sélectionner la commande "positionner un marque-page" dans le menu "édition", ou bien utiliser un raccourci clavier (par défaut CTRL + K).

Les marque-pages sont symbolisés par l'icône suivante dans la colone d'icônes (à condition que la colonne des icônes d'état soit visible, voir <jump=SHM_contents0039>Options générales de l'éditeur</jump>) :
\par\ql\{bml Icone_MarquePages_256.bmp\}\par\ql

Une fois les marque-pages positionnés, vous pouvez soit aller directement à un marque-page précis en faisant un double-clic sur la ligne, soit les parcourir successivement en faisant "référence suivante" ou "référence précédente" dans le menu d'édition (commandes généralement appelées avec les raccourcis F4 et Maj + F4).

Vous avez bien sûr la possibilité d'effacer un marque-page, ou bien la totalité des marque-pages (commande du menu "édition").
----- SHM ---- page 29 ---- 
Cette partie permer de créer et de modifier les boîtes de dialogue VCL. Vous pouvez soit créer une nouvelle fenêtre à partir des modèles proposés ou d'une fenêtre existante, soit ouvrir un fichier RC ou DFM.

Pour plus de détails sur la création d'une nouvelle boîte de dialogue, voir <jump=SHM_contents0045>Création d'une nouvelle fenêtre de dialogue</jump>.

Cette partie création contient plusieurs éléments permettant la construction et la modification des éléments :

<boxl>Tree-view des composants</box>

Dans la partie gauche, un tree-view (arborescence) contient les boîtes de dialogues et leurs composants.

Ce tree-view contient au niveau 0 le ou les boîtes de dialogue. Dans le cas d'un fichier RC, on peut avoir plusieurs boîtes dans un même fichier. Dans le cas d'un DFM, il ne peut y avoir qu'une seule boîte par fichier. Ensuite, chaque boîte ou composant contient ses composants enfants.

Vous pouvez visualiser une boîte par un double-clic sur le noeud correspondant. La fenêtre apparait et est mise au premier plan.

Vous pouvez sélectionner un composant en cliquant dessus dans l'arborescence. Il est automatiquement sélectionné dans la boîte de dialogue elle-même. Un entourage de couleur permet de voir quels composants sont sélectionnés. Pour sélectionner plusieurs composants en même temps, sélectionnez d'autres composants en tenant le touche CTRL ou MAJ enfoncée.

<boxl>Menu contextuel</box>

Un clic droit sur un noeud de l'arborescence (représentant un composant ou une boîte) fait apparaitre un menu popup avec plusieurs options :

\par\ql\{bml NouveauDialogue_Popup_256.bmp\}\par\ql

<bullet.bmp> <u>Aspect</u> : permet d'aligner les contrôles sélectionnés, soit ensemble, soit sur la grille, soit encore dans la fenêtre principale. Certaines de ces options seront grisées si un seul composant est sélectionné, ou bien si c'est la fenêtre principale qui est sélectionnée.

<bullet.bmp> <u>Couper</u> : permet de copier les composants sélectionnés dans le presse-papier, puis de les supprimer.

<bullet.bmp> <u>Copier</u> : permet de copier les composants sélectionnés dans le presse-papier.

<bullet.bmp> <u>Coller</u> : permet de coller les composants du presse-papier sous le noeud sélectionné.

<bullet.bmp> <u>Supprimer</u> : supprime le ou les composant(s) sélectionné(s). Si vous supprimez par erreur un composant, vous pouvez défaire la suppression avec un UNDO (généralement CTRL Z).

<bullet.bmp> <u>Propriétés</u> : Ouvre une boîte de dialogue permettant d'afficher et de modifier les propriété du ou des composants sélectionnés. Si plusieurs composants sont sélectionnés, seuls les composants communs à tous les composants sélectionnés sont affichés. Pour plus de détails, voir <jump=SHM_contents0046>Propriétés d'un contrôle</jump>.

<boxl>Grille d'alignement</box>

La grille permet d'aligner automatiquement les composants sur un multiple entier de pixels. Ca évite d'avoir un ou deux pixels d'écart entre les composants, écart qui ne se voit pas toujours au premier coup d'oeil. Vous pouvez régler l'espacement de la grille en X et en Y.

<boxl>Création d'un composant</box>

Pour créer un nouveau composant, cliquez sur l'icône du composant choisi, puis positionnez-le dans la boîte de dialogue en tenant le bouton gauche de la souris enfoncée. Le sens de saisie (gauche-droite et haut-bas) n'a pas d'importance. La fenêtre de propriétés s'ouvre ensuite automatiquement pour saisir les informations complémentaires, comme le nom, les ancrages, etc... Pour plus de détails sur les propriétés des composants, voir <jump=SHM_contents0046>Propriétés d'un contrôle</jump>.

<boxl>Modification d'un composant</box>

Vous pouvez modifier graphiquement les composants, pour changer soit leurs emplacement, soit leurs tailles, soit leurs ancrages. Sélectionnez-le en cliquant dessus ou bien en cliquant sur son nom dans le tree-view. Le composant sélectionné se visualise avec un entourage de couleur. Vous pouvez ensuite le déplacer ou le redimensionner en déplaçant le bord de l'entourage, ou bien le cadre en entier (la forme du curseur vous indique l'action qui va être effectuée). Pour changer l'ancrage, cliquez sur le petit carré symbolisant l'ancrage en tenant la touche CTRL enfoncée. Le carré change de couleur. Vous pouvez déplacer, redimensionner ou modifier plusieurs composants en même temps si plusieurs sont sélectionnés.

Pour modifier les propriétés du composant, faites un clic droit sur le composant. Il apparait le même menu contextuel que dans le tree-view (voir plus haut).
----- SHM ---- page 30 ---- 
Les macro-instructions permettent d'enregistrer une suite de touches ou d'actions du clavier, puis de les rejouer ensuite une ou plusieurs fois.

Lancer la commande "Enregistrer une macro", puis tapez le texte et les commandes que vous souhaitez enregistrer. Lorsque vous avez fini, cliquez sur "Arrêter l'enregistrement" dans le menu. Votre macro est mémorisée. Vous pouvez ensuite l'exécuter autant de fois que vous le souhaitez. Il y a cependant quelques limitations :

<bullet.bmp> Vous ne pouvez pas enregistrer d'actions de la souris.
<bullet.bmp> Vous ne pouvez pas enregistrer les actions clavier dans les boîtes de dialogue (fonction de recherche par exemple). En revanche, les raccourcis clavier fonctionnent, et vous pouvez par exemple utiliser la touche F3 pour chercher l'occurrence suivante.
----- SHM ---- page 31 ---- 
Le programme FVCLIDE peut être lancé par une ligne de commande, par exemple dans un fichier batch ou bien via la fonctionnalité "Envoyer vers" de l'explorateur. Dans ce cas, l'espace de travail n'est pas mémorisé.

La syntaxe est la suivante :

<b>FVCLIDE.exe <i>"Nom du fichier 1"</i> [<i>"Nom du fichier 2"</i>] [<i>"Nom du fichier 3"</i>] ...</b>

----- SHM ---- page 32 ---- 

Les messages d'erreur sont de trois types :

<bullet.bmp> <u>Les messages d'information</u> qui affichent une précision, un message à caractère non indispensable, ...

<bullet.bmp> <u>Les messages d'avertissement</u> qui indiquent une erreur non critique.

<bullet.bmp> <u>Les messages d'erreur</u> qui apparaissent lorsque survient une erreur empêchant le déroulement normal du traitement.

\par\qc\{bmc MessageErreur_256.bmp\}\par\ql

Il est parfois possible, essentiellement sur les messages d'information, de cocher la case "Ne plus afficher ce message". Dans ce cas, la réponse que vous donnerez deviendra définitive pour tous les messages du même type. Il est possible de remettre à zéro une ou plusieurs réponses automatiques dans la partie "Options de l'éditeur" (voir <jump=SHM_contents0023>Le menu options</jump> et <jump=SHM_contents0044>Réponses par défaut</jump>).
----- SHM ---- page 33 ---- 
La fenêtre de recherche et de remplacement permet de chercher un texte dans un ou plusieurs fichiers, et éventuellement de le remplacer par un autre, avec des options permettant de préciser la recherche (recherche en début ou en fin de ligne, dans les chaînes, les commentaires, par exemple).

Les différentes fonctions sont dans des onglets de la fenêtre principale (certaines options ne sont visibles que dans certains onglets):

\par\qc\{bmc SearchAndReplace.bmp\}\par\ql

\par\qc\{bmc SearchAndReplaceFiles.bmp\}\par\ql

<boxl><b>Options de recherche</b></box>

<bullet.bmp> <u>Mot entier</u> : Permet de rechercher un mot isolé dans le texte. Les caractères permettant de faire la différence entre un mot et les séparations dépendent du langage du fichier. Et règle générale les caractères alpha-numériques font partie des mots, pour les caractères accentués, le tiret normal "-" et le tiret bas "_", ça dépend du langage, et tous les autres caractères sont en général considérés comme des caractères de séparation (espaces, tabulations, retours à la ligne, virgules, points, points-virgules, etc...).

<bullet.bmp> <u>Différentier MAJ/min</u> : Si cette option est cochée, la recherche fera la différence entre les caractères minuscules et majuscules.

<bullet.bmp> <u>En début de ligne</u> : La recherche est faite uniquement au début de chaque ligne, après élimination des espaces et tabulations de début de ligne.

<bullet.bmp> <u>En fin de ligne</u> : La recherche est faite uniquement à la fin de chaque ligne, après élimination des espaces et tabulations de fin de ligne.

<bullet.bmp> <u>Uniquement dans les commentaires</u> : La recherche est faite uniquement dans les commentaires. Le marqueur des commentaires dépend du langage du fichier.

<bullet.bmp> <u>Uniquement hors des commentaires</u> : La recherche est faite uniquement en dehors des commentaires. Le marqueur des commentaires dépend du langage du fichier.

<bullet.bmp> <u>Uniquement dans les guillements</u> : La recherche est faite uniquement dans les chaînes de caractères. Le délimiteur de chaînes dépend du langage du fichier (en général les guillemets).

<bullet.bmp> <u>Uniquement hors des guillements</u> : La recherche est faite uniquement en dehors des chaînes de caractères. Le délimiteur de chaînes dépend du langage du fichier (en général les guillemets).

<bullet.bmp> <u>Expression régulière</u> : La chaîne de recherche est une expression régulière et la recherche est faite en fonction de cela.

<boxl><b>Direction</b></box>

<bullet.bmp> <u>Vers le haut</u> : La recherche se fait vers le début du fichier, de bas en haut.

<bullet.bmp> <u>Vers le bas</u> : La recherche se fait vers la fin du fichier, de haut en bas.

<boxl><b>Origine</b></box>

<bullet.bmp> <u>Depuis le début</u> : La recherche démarre au début du fichier (ou à la fin du fichier si la direction est "vers le haut").

<bullet.bmp> <u>A partir du curseur</u> : La recherche se fait à partir de la position du curseur texte.

<bullet.bmp> <u>Boucler en fin de fichier</u> : Lorsque le programme arrive en fin de fichier (en début de fichier si option "vers le haut"), la recherche se continue au début du fichier (à la fin si option "vers le haut").

<boxl><b>Portée</b></box>

<bullet.bmp> <u>Dans tout le texte</u> : La recherche se fait dans l'intégralité du fichier.

<bullet.bmp> <u>Dans le texte sélectionné</u> : La recherche se fait uniquement dans le texte sélectionné.

<boxl><b>Chercher dans</b></box>

<bullet.bmp> <u>Fichiers du projet</u> : La recherche se fait dans tous les fichiers du projet.

<bullet.bmp> <u>Fichiers de tous les projets</u> : La recherche se fait dans tous les fichiers de tous les projets (c'est à dire dans l'espace de travail).

<bullet.bmp> <u>Fichiers ouverts</u> : La recherche se fait dans tous les fichiers ouverts.

<bullet.bmp> <u>Répertoire</u> : La recherche se fait dans les fichiers d'un répertoire, et éventuellement ses sous-répertoires (voir option ci-dessous)

<bullet.bmp> <u>Sous-répertoires</u> : Si cette case est cochée, la recherche se fait dans tous les sous-répertoires, et récursivement dans les sous-répertoires des sous-répertoires.

<bullet.bmp> <u>Répertoire</u> : Indiquer le répertoire dans lequel chercher les fichiers. Un bouton permet de parcourir l'arborescence des fichiers pour choisir un répertoire.

<bullet.bmp> <u>Extensions</u> : Indiquer l'extension des fichiers dans lesquels effectuer la recherche. Vous pouvez indiquer plusieurs extensions séparées par un point-virgule, ou bien laisser vide pour parcourir tous les fichiers. Par exemple :
<b>*.c;*.cpp;*.h;</b>

<boxl><b>Boutons</b></box>

<bullet.bmp> <u>Chercher</u> ou  <u>Suivant</u> : Lance ou continue la recherche. Le curseur texte se positionne sur l'occurrence suivante trouvée.

<bullet.bmp> <u>Remplacer</u> : Remplace l'occurrence sélectionnée. Ce bouton est grisé si aucune occurrence n'est encore sélectionnée (Il faut alors commencer par faire "Chercher").

<bullet.bmp> <u>Tout</u> : Cherche ou remplace la chaîne définie dans tout le fichier. Les occurrences trouvées s'affichent dans l'onglet "Recherche" de la fenêtre de résultat. Vous pourrez ensuite positionner le curseur dessus en faisant un double-clic sur une ligne.
----- SHM ---- page 34 ---- 
Il arrive souvent qu'on ait à saisir des bouts de code qui, sans être tout à fait identiques, ont de nombreuses ressemblances. Les modèles de code permettent de saisir rapidemment ces parties de code, qui autrement auraient dû être entrées à l'aide de nombreux copiés-collés.
On saisit le modèle dans un petit éditeur. Les parties fixes sont tapées telles quelles, les "variables" sont saisies entre triples accolades. Le nom de la variable peut être librement choisie (espaces et accents autorisés). Voici par exemple le modèle de code permettant de faire une simple boucle <color=10><b>for</b></color>:

\par\qc\{bmc ModèleDeCode_Modification_256.bmp\}\par\ql

Au moment de taper le modèle de code dans le texte, l'éditeur regroupe les noms de variables identiques, et demande à l'utilisateur de remplir leur contenu (le texte à gauche correspond au nom de la variable qui était entre accolades) :

\par\qc\{bmc ModèleDeCode_SaisieParams.bmp\}\par\ql

Puis le programme remplace les variables par leur valeur, et insère le texte à la position du curseur, comme si le texte était tapé au clavier:

\par\qc\{bmc ModèleDeCode_CodeGénéré_256.bmp\}\par\ql
----- SHM ---- page 35 ---- 
L'outil de statistiques permet de compter le nombre de lignes de code, les lignes vides, le nombre de caractères, etc... Le traitement se fait sur plusieurs fichiers, qui peuvent être soit les fichiers ouverts, soit les fichiers du projet, soit encore un répertoire et éventuellement ses sous-répertoires. Le résultat du traitement s'affiche ensuite dans la boîte d'édition en dessous:

\par\qc\{bmc Statistiques_FenêtrePrincipale_256.bmp\}\par\ql

Il est possible de cocher la case "Cumuler les résultats" pour faire plusieurs statistiques successives sans remise à zéro.
----- SHM ---- page 36 ---- 
\par\ql\{bml Conversion_nombres_256.bmp\}\par\ql

Cette fenêtre permet d'obtenir la conversion de nombres au format décimal, hexadécimal, chaîne, nombre réel, signé ou pas. Vous pouvez faire une rotation circulaire bit à bit vers la gauche ou la droite, ou une inversion octet par octet (pour transformer les formats "big endian" en "little endian" et réciproquement).

Les nombres sont juste affichés et convertis. Vous pouvez ensuite faire un copié-collé pour les mettre dans votre programme.
----- SHM ---- page 37 ---- 
Cette fenêtre permet de paramétrer vos outils personnalisés, c'est à dire des programmes externes que vous pourrez ensuite appeler directement depuis le menu de l'application.

\par\qc\{bmc OutilsUtilisateur_Liste_256.bmp\}\par\ql

Pour ajouter un nouvel outil, cliquez sur le bouton "Ajout". Une nouvelle boîte de dialogue s'ouvre :

\par\qc\{bmc OutilsUtilisateur_Ajout_256.bmp\}\par\ql

Il est possible de paramétrer le nom, le programme lui-même, les arguments d'appel, et le répertoire d'exécution.

<bullet.bmp> <u>Nom</u> : Nom qui apparaitra dans le menu

<bullet.bmp> <u>Programme</u> : Chemin complet du programme qui sera lancé

<bullet.bmp> <u>Arguments d'appel</u> : Argument du programme

<bullet.bmp> <u>Répertoire d'exécution</u> : Répertoire dans lequel sera lancé le programme.

Ces outils apparaitront ensuite dans ce même menu, sous la barre de séparation :

\par\qc\{bmc OutilsUtilisateur_Menu_256.bmp\}\par\ql
----- SHM ---- page 38 ---- 
Ces options déterminent le comportement de l'éditeur en général.

<onestep.bmp> <b>Nombre d'espaces des tabulations</b>

Ce nombre définit le nombre d'espaces correspondants à une tabulation. Ce nombre intervient lorsque vous tapez sur la touche tabulation, ou bien lorsque vous transformez les espaces en tabulations ou réciproquement. Soyez prudents lorsque vous modifiez cette valeur, les fichiers qui contiennent à la fois des espaces et des tabulations risquent de voir leur indentation totalement désorganisée.

<onestep.bmp> <b>Transformation des espaces en tabulations</b>

Cette option permet de transformer automatiquement les espaces en tabulations lorsque vous tapez du texte. Elle permet d'éviter une perte de l'indentation si vous changez le nombre d'espaces des tabulations (ou bien si vous changez d'éditeur de texte).

<onestep.bmp> <b>Transformation des tabulations en espaces</b>

Cette option fait l'inverse de la précédente, pour les mêmes raisons. A vous de choisir sous quelle forme vous souhaitez stocker les fichiers: avec uniquement des tabulations (mais certains éditeurs ou comparateurs de fichiers peuvent être perturbés par ces tabulations), ou bien avec uniquement des espaces (mais dans ce cas le nombre d'espaces des indentations est figé).

Cette option est incompatible avec la précédente. Sachez également que dans l'éditeur Free-VCL il existe des fonctions qui permettent de transformer après-coup les espaces en tabulations ou inversement (voir <jump=SHM_contents0018>Fonctions d'édition</jump>).

\par\qc\{bmc EdiOptions_256.bmp\}\par\ql

<onestep.bmp> <b>Afficher les numéros de ligne</b>

Vous pouvez afficher ou pas les numéros de ligne à gauche de la fenêtre d'édition. Cette option ne s'applique pas à l'affichage des fichiers binaires.

<onestep.bmp> <b>Afficher les icônes d'état</b>

Les icônes d'état (marque-pages, points d'arrêt, ou instruction courante se mettent dans une colonne à droite des numéros de ligne. Vous avez le choix d'afficher cette colonne ou pas.

<onestep.bmp> <b>Fermeture automatique des parenthèses</b>

Cette option ajoute automatiquement une parenthèse fermante lorsque vous en ouvrez une, ou bien une accolade fermante lorsque vous en ouvrez une. Ceci vous évite donc de les taper.

<onestep.bmp> <b>Indentation automatique</b>

Cette option permet d'indenter automatiquement votre code lorsque vous le tapez (lors des retours à la ligne notamment).

<onestep.bmp> <b>Curseur après la fin de ligne</b>

Lorsque cette option est activée, il est possible de positionner le curseur n'importe où dans l'écran, y compris après la fin des lignes. Lorsqu'elle est désactivée, le curseur se positionne automatiquement sur le dernier caractère si vous cliquez après la fin de la ligne.

<onestep.bmp> <b>Undo/redo des déplacements curseur</b>

Lorsque cette option est activée, les déplacements du curseur texte sont mémorisés comme une action qu'il est possible de défaire. Sinon, seules les modifications réelles sont mémorisées. A noter : plusieurs déplacements successifs du curseur sont mémorisés comme une seule action.

<onestep.bmp> <b>Onglets sur plusieurs lignes</b>

\par\qc\{bmc Onglets_Multiline_256.bmp\}\par\ql


\par\qc\{bmc Onglets_Monoline_256.bmp\}\par\ql

Lorsque le nombre d'onglets correspondants aux fichiers ouverts dépasse la largeur de la fenêtre d'édition, les onglets peuvent soit se mettre sur plusieurs lignes, soit se mettre sur une seule ligne avec un bouton de défilement. Cette option permet de choisir entre ces deux possibilités.

<onestep.bmp> <b>Sauver les modifications avant compilation</b>

Permer d'enregistrer automatiquement les fichiers modifiés lorsqu'on lance la construction d'un projet.

<onestep.bmp> <b>Activer l'autocomplétion</b>

Permet d'activer l'autocomplétion de code dans les fichiers des applications.

<onestep.bmp> <b>Activer la transparence des fenêtres</b>

Certaines fenêtres (la fenêtre de recherche et de remplacement, par exemple) peuvent être plus ou moins transparentes selon la position de la souris, ce qui permet de visualiser le texte qui est en dessous. Cette option permet d'activer ou de désactiver la transparence.
----- SHM ---- page 39 ---- 
La fenêtre des raccourcis vous permet de définir des racourcis clavier pour chaque commande de l'éditeur. La partie gauche de la fenêtre reproduit les commandes du menu, avec la même arborescence. Faites un double-clic sur une ligne pour l'ajouter dans la liste des raccourcis. Ensuite, définissez le raccourci lui-même qui peut être saisi de différentes manières:

\par\qc\{bmc Raccourcis_FenêtrePrincipale_256.bmp\}\par\ql

<bullet.bmp> Soit en choisissant une touche dans la liste et en cliquant les touches ALT, SHIFT et CTRL correspondantes au raccourci.
<bullet.bmp> Soit en positionnant le curseur dans la boîte de saisie du raccourci, et en tapant le raccourci directement au clavier.
<bullet.bmp> Il est également possible de définir des raccourcis pré-définis (bouton "Valeurs par défaut") .

Les raccourcis spécifiques à l'éditeur (flèches de direction, coupé, copié, collé, etc...) ne peuvent ni être modifiés ni être utilisés pour lancer d'autres commandes.
----- SHM ---- page 40 ---- 
Vous pouvez personnaliser les couleurs du texte dans l'éditeur. Pour chaque catégorie de texte (texte normal, commentaires, chaînes, nombres, etc...), choisissez dans les listes la couleur du texte et la couleur du fond, et le style de caractères (gras ou incliné). Il est également possible de choisir un style pré-défini dans la liste.
La liste des langages vous permet de visualiser le style avec les différents langages disponibles (pour certains, il se peut que les couleurs ne soient pas toutes utiles).

\par\qc\{bmc Coloration_FenêtrePrincipale_256.bmp\}\par\ql

----- SHM ---- page 41 ---- 
\par\qc\{bmc PoliceCaractères_Saisie_256.bmp\}\par\ql

Cette boîte de dialogue permet de choisir le style et la hauteur des caractères utilisée pour afficher le texte. Vous devez choisir une police de caractères à largeur fixe des caractères. Le programme ne liste que les polices à espacement fixe, mais certaines polices définies comme fixes ont quant même parfois une largeur variable (notamment lorqu'on mélange les caractères gras et non gras). C'est le cas de la police "Courier", par exemple (Utilisez plutôt "Courier New").
----- SHM ---- page 42 ---- 
Ces options s'appliquent à la fonction de formatage automatique du code du menu "outils" (voir <jump=SHM_contents0022>Le menu outils</jump>).

\par\qc\{bmc FormatageCode_Paramètres_256.bmp\}\par\ql

<onestep.bmp> <b>Accolades en fin de ligne</b>

Si cette option est cochée, les accolades ouvrantes seront en fin de ligne. Sinon, elles seront en début de ligne suivante. Cette option n'a aucun effet sur les codes sources en PASCAL ou BASIC, car dans ces langages le mot-clé <color=10><b>then</b></color> est obligatoirement en fin de ligne lorsqu'il débute un bloc d'instructions.

<onestep.bmp> <b>Espaces après parenthèses</b>

Permet d'insérer automatiquement un espace après chaque parenthèse ouvrante, et avant chaque parenthèse fermante. Si la parenthèse est vide, elle ne contiendra qu'un seul espace.

<onestep.bmp> <b>Langage</b>

Permet de choisir le langage de l'exemple affiché, pour pouvoir voir en temps réel les effets des modifications. L'option choisie n'est pas mémorisée.
----- SHM ---- page 43 ---- 
Lorsque vous cochez la case "Ne plus afficher ce message" dans un message d'erreur (voir <jump=SHM_contents0033>Messages d'information et d'erreur</jump>), les réponses automatiques sont mémorisées dans la base de registre. Vous pouvez effacer une ou toutes les réponses par défaut à l'aide de cette boîte de dialogue :

\par\qc\{bmc RéponsesDéfaut_Général_256.bmp\}\par\ql

Cliquez sur une réponse puis sur le bouton "Supprimer" pour effacer une réponse, ou sur "Mise à zéro" pour toutes les supprimer.
----- SHM ---- page 44 ---- 

Cette boîte de dialogue vous permet de créer une nouvelle fenêtre de dialogue :

\par\qc\{bmc NouveauDialogue_Creation_256.bmp\}\par\ql

Entrez le nom de l'unité, le titre du dialogue, et le type de dialogue à créer parmi les choix suivants: 

<bullet.bmp> Fenêtre complètement vide.

<bullet.bmp> Fenêtre avec juste les boutons "Ok", "Annuler" et "Aide" positionnés en bas.

<bullet.bmp> Fenêtre à partir d'une structure que vous souhaitez renseigner. Mettez votre structure dans la partie "Informations complémentaires". Le programme créera automatiquement une fenêtre permettant la saisie de cette structure. Voir ci-dessous pour plus de détails.

<bullet.bmp> Fenêtre à partir d'une autre fenêtre existante (c'est à dire ouverte au moment où vous la créerez). Dans ce cas, choisissez une fenêtre dans la liste qui apparait en dessous. Le programme crée alors une nouvelle fenêtre qui ressemblera autant que faire se peut à la fenêtre que vous aurez choisi.

Dans tous les cas (sauf fenêtre existante), un bouton "Aperçu" vous permet de prévisualiser le dialogue que vous allez créer.

<boxl><b>Création d'un dialogue à partir d'une structure</b></box>

Cette option vous permet de créer facilement une nouvelle boîte de dialogue. Entrez dans la partie "Informations complémentaires" les champs à saisir (même syntaxe que dans une structure struct), par exemple :

\par\qc\{bmc NouveauDialogue_Creation_Struct_256.bmp\}\par\ql

Et en un clic, le dialogue permettant la saisie de cette structure est automatiquement créé, il contient le code correspondant à la fenêtre suivante:

\par\qc\{bmc NouveauDialogue_Aperçu_256.bmp\}\par\ql

Attention, les commentaires dans la structure sont importants: ils servent à construire les textes de gauche.
Le bouton "Parcourir" (et son code correspondant) est automatiquement ajouté lorsque le texte associé au contrôle contient le mot "Chemin", ou "Fichier" ("Fichier photo" dans l'exemple).

Evidemment, quelques ajustements seront sans doute nécessaires:

<onestep.bmp> Par exemple, ici, un contrôle UpDown n'est pas adapté à la saisie d'un code postal. Mais il est plus facile de supprimer des composants que d'en créer des nouveaux.
<onestep.bmp> Il vous faudra aussi écrire le code exécuté lorsqu'on clique sur "Ok" ou "Annuler" (ça, aucun outil ne pourra l'écrire automatiquement à votre place).

----- SHM ---- page 45 ---- 
Cette fenêtre permet de saisir les propriétés des contrôles. Le plus souvent, il s'agit de composants (sous-entendu graphiques). Aussi, dans la suite on parlera généralement de composants, même si le terme n'est pas totalement exact.

Cette boîte possède généralement trois onglets, que nous allons détailler ci-dessous :

<boxl><b>Nom et position</b></box>

Cet onglet regroupe les principales informations d'un contrôle :

<bullet.bmp> <u>Nom</u> : c'est le nom qui apparaitra dans le tree-view. Il correspond à la propriété "Name". Bien que ce ne soit pas conseillé, vous pouvez y mettre des espaces et des accents.

<bullet.bmp> <u>Point supérieur gauche</u> : coordonnées du point supérieur gauche du composant.

<bullet.bmp> <u>Point inférieur droit</u> : coordonnées du point inférieur droit du composant. Le fait de changer ces valeurs change la largeur et la hauteur.

<bullet.bmp> <u>Dimensions</u> : largeur et hauteur du composant. Le fait de changer ces valeurs change les coordonnées du point inférieur droit

<bullet.bmp> <u>Coordonnées relatives ou absolues</u> : les coordonnées sont soit absolues (exprimées en pixels par rapport à la zone client du composant parent), soit relatives aux points d'ancrages (par rapport au bord droit ou gauche, puis au bord supérieur ou inférieur, suivant les ancrages du composant. Cette option ne change que l'affichage pour éviter des calculs fastidieux, dans le fichier les coordonnées sont toujours enregistrées en absolu.

<bullet.bmp> <u>Aligner sur l'objet parent</u> : ce bouton permet d'aligner automatiquement le composant sur l'objet auquel il appartient. Cette action ne fait que changer les coordonnées, il ne faut pas la confondre avec la propriété <b>Align</b> des composants.

Si le contrôle n'est pas un composant graphique, les coordonnées ne sont utiles que pendant la construction (pour positionner l'icône).

<boxl><b>Ancrages</b></box>

Cet onglet permet de modifier les ancrages, c'est à dire le comportement du composant lorsqu'on redimensionne le composant parent auquel il appartient : le composant peut se redimensionner ou se déplacer avec le bord droit ou inférieur de la fenêtre, par exemple.

Cliquez sur les carrés symbolisant les ancrages, ou bien choisissez un des ancrages pré-définis dans la partie droite.

<boxl><b>Propriétés</b></box>

Les propriétés sont variables suivant les composants. On retrouve souvent les propriétés "Caption", "Width", "Height", "Visible". Consultez l'aide de chaque élément pour plus de détails sur un composant (voir <jump=SHM_contents0024>Le menu aide</jump>, ou bien l'{\uldb aide en ligne}{\v !ExecFile(www.freevcl.fr/help,,,)} sur internet.
----- SHM ---- page 46 ---- 
<u><b>Outil de migration VCL2FreeVCL</b></u>

L'outil <b>VCL2FreeVCL</b> vous facilite la transformations des programmes VCL en programmes FreeVCL. Il traite automatiquement les petites différences de syntaxe, c'est à dire:

<onestep.bmp> Transformation des <color=10><b>#include <vcl.h></b></color> en <color=10><b>#include <FreeVCL.h></b></color>.

<onestep.bmp> Transformation des <color=10><b>__fastcall</b></color> en <b>FASTCALL</b>.

<onestep.bmp> Suppression des mot-clés et pragmas spécifiques à Builder <color=10><b>__published</b></color>, <color=10><b>#pragma hdrstop</b></color> et <color=10><b>#pragma package</b></color>.

<onestep.bmp> Ajout des macros <b>FVCL_BEGIN_COMPONENTS</b> / <b>FVCL_END_COMPONENTS</b> et <b>FVCL_BEGIN_EVENTS</b> / <b>FVCL_END_EVENTS</b>.

<onestep.bmp> Ordre des composants en accord avec le DFM.

<onestep.bmp> Création automatique du RC s'il n'existe pas.

<onestep.bmp> Eventuellement, ajout de la macro _T( ).

Tous les fichiers sources (.cpp, .h) du répertoire choisi (et des sous répertoires si vous avez coché la case) sont transformés. Les anciens fichiers sont renommés en .old (.cpp.old et .h.old).

L'option "Chaînes unicode" permet de rajouter automatiquement la macro _T( ) à toutes vos chaînes. Il est conseillé de laisser cette option cochée car ça vous évitera un traitement ultérieur, même si vous ne souhaitez pas transformer dans l'immédiat votre projet en unicode (la macro n'a aucun d'effet si l'option UNICODE n'est pas activée dans le projet). Voir <jump=SHM_contents0006>Unicode</jump> pour plus de détails.


<u><b>Il vous restera ensuite à transformer à la main les derniers points suivants:</b></u>

<onestep.bmp> Ajout du mot-clé <color=10><b>const</b></color> (que Builder gère de façon assez peu rigoureuse) lorsque c'est nécessaire.

<onestep.bmp> Changement du prototype de constructeur des TForm.

<onestep.bmp> Quelques petits aménagements à faire dans le WinMain du projet principal: <color=10><b>new</b></color> et <color=10><b>delete</b></color> de la fenêtre principale, par exemple (voir <jump=SHM_contents0003>Mon premier programme</jump>).

Le programme met un commentaire aux principaux endroits où un traitement manuel doit être fait, de cette manière:
<color=7><b>//! @todo [VCL2FreeVCL] ...</b></color>

----- SHM ---- page 47 ---- 
<boxl><b>Chemin des inclusions</b></box>

Dans le menu, choisir "Tools", puis "Options". Puis, dans la boîte de dialogue suivante, choisir l'onglet "Directories", sélectionner "Include Files" dans la liste déroulante, puis cliquez sur l'icône "New". Entrez le chemin des fichiers .h et enfin validez avec le bouton "Ok".

\par\qc\{bmc Config_Include_V6_16.bmp\}\par\ql

<boxl><b>Chemin des librairies</b></box>

Même chose à peu de choses près pour le chemin des .lib.

\par\qc\{bmc Config_Lib_V6_16.bmp\}\par\ql

----- SHM ---- page 48 ---- 
<boxl><b>Chemin des inclusions</b></box>

Dans le menu, choisir "Tools", puis "Options". Puis, dans la boîte de dialogue suivante, choisir dans le tree-view "VC++ Directories", sélectionner "Include Files" dans la liste déroulante, puis cliquez sur le bouton "New". Entrez le chemin des fichiers .h et enfin validez avec le bouton "Ok".

\par\qc\{bmc Config_Include_VE_16.bmp\}\par\ql

<boxl><b>Chemin des librairies</b></box>

Même chose à peu de choses près pour le chemin des .lib.

\par\qc\{bmc Config_Lib_VE_16.bmp\}\par\ql

----- SHM ---- page 49 ---- 
<boxl><b>Chemin des inclusions</b></box>

Dans le menu, choisir "Settings", puis "Compiler and debugger". Puis, dans la boîte de dialogue suivante, choisir "Global compiler settings" dans la fenêtre de gauche, sélectionner les onglets "Search directories" et "Compiler", puis cliquez sur le bouton "Add". Entrez le chemin des fichiers .h et enfin validez avec le bouton "Ok".

\par\qc\{bmc Config_Include_CB_256.bmp\}\par\ql
----- SHM ---- page 50 ---- 
<b><u>Pourquoi mes fenêtres ne font pas la taille que j'ai indiqué dans le DFM ?</u></b>

La taille des fenêtres dépend du thème Windows. En effet, selon le thème, la taille de la barre de titre, des bordures peut varier. Si on gardait la taille définie dans le DFM, la zone utile serait augmentée ou réduite en fonction des paramètres d'affichage, et rendrait problématique le positionnement des composants à l'intérieur. La taille des boîtes de dialogue est donc définie pour une configuration standard (Thème "Windows Classique") dans le DFM, et elle est légèrement agrandie ou réduite pour que le rectangle client soit indépendant du thème.
----- SHM ---- page 51 ---- 
<boxc><b>Erreurs de compilation</b></box>

<b><u>"Error: 'struct _dp_Getxxxx_Setxxxx' has no members ..."</u></b>

Voir <jump=SHM_contents0009>Problèmes connus</jump>


<b><u>"Error: Non-lvalue in assignment"</u></b>

Voir <jump=SHM_contents0009>Problèmes connus</jump>


<b><u>"Error: unresolved external symbol (<i>quelque chose avec char *</i>)</u></b>

Vous avez certainement compilé un programme UNICODE avec une lib non UNICODE (à moins que ce ne soit le contraire). Les .lib qui sont dans VisualStudio sont toutes en UNICODE. Les autres (c'est à dire celles qui sont dans VisualStudio_6 et CodeBlocks) ne le sont pas.

----- SHM ---- page 52 ---- 
Voici un rapide résumée des versions de Free VCL et de leurs améliorations:

<b><u>Free VCL 1.1.1.1</u></b>

Béta-version

<b><u>Free VCL 1.1.1.2</u></b>

Nombreux bugs corrigés

<b><u>Free VCL 1.1.2.1</u></b>

Portage Windows CE
Compatibilité unicode
Classe TTreeView implémentée
Classe TListView améliorée
Composants FreeVCL_XFile (Permet de générer des fichiers PDF et DBF)
Composants FreeVCL_Web (TCppWebBrowser et sockets)
Nouveaux exemples
Doc en anglais en plus du français

<b><u>Free VCL 1.1.2.2</u></b>

Correction d'un bug qui provoquait l'erreur "Cette application n'est pas une application valide" sous windows CE.
Nombreux bugs dans la classe TCanvas.

<b><u>Free VCL 1.1.3.1</u></b>

La classe TCanvas dérive maintenant d'une classe abstraite TCustomCanvas.
Ajout de la classe TMetafile.
Ajout d'un exemple d'utilisation d'un objet TMetafile.

<b><u>Free VCL 1.1.4.1</u></b>

Ajout de la classe TLink.
Ajout des classes TStream, TMemoryStream, TFileStream.

<b><u>Free VCL 1.1.5.1</u></b>

Ajout des classes TAction et TColorBox.

<b><u>Free VCL 1.2.1.1</u></b>

Compatibilité 64 bits.
Réorganisation et renommage des répertoires.

<b><u>Free VCL 1.3.1.1</u></b>

Editeur intégré.
Outil CreateUnit intégré à l'éditeur 
Changement de la méthode d'appel des évènements.
Nouveaux composants.
Suppression de la compatibilité CE (non utilisée).
----- SHM ---- page 53 ---- 
Je n'aurait jamais pu créer ce logiciel sans les outils suivants:


<boxl><b>Code::Blocks {\uldb http://www.codeblocks.org}{\v !ExecFile(http://www.codeblocks.org,,9,)}</b></box>

Compilateur gratuit, qui n'a rien à envier à d'autres compilateurs payants et très chers que je suis contraint d'utiliser quotidiennement (Et que je ne peux hélas pas nommer).

Simple, clair, et évolutif grâce à une interface permettant le développement de plugins.



<boxl><b>Embedded Visual C .Net {\uldb http://www.microsoft.com/downloads/details.aspx}{\v !ExecFile(http://www.microsoft.com/downloads/details.aspx?FamilyId=1DACDB3D-50D1-41B2-A107-FA75AE960856&displaylang=en,,9,)}</b></box>

Je me dois également de remercier monsieur Microsoft, qui fournit gratuitement cet outil (pour des raisons commerciales, mais bon, on va pas chipoter) pour programmer en Windows CE. Pas toujours facile d'utilisation, mais ça marche.



<boxl><b>Inno Setup  {\uldb http://www.innosetup.com}{\v !ExecFile(http://www.innosetup.com,,9,)}</b></box>

Programme d'installation. L'essayer c'est l'adopter.



<boxl><b>DOXYGEN  {\uldb http://www.doxygen.org/index.html}{\v !ExecFile(http://www.doxygen.org/index.html,,9,)}</b></box>

Documentation automatique des sources. Vous n'avez plus rien à faire pour avoir une doc toujours à jour.



<boxl><b>Shalom Help Maker  {\uldb http://www.danish-shareware.dk/soft/shelpm}{\v !ExecFile(http://www.danish-shareware.dk/soft/shelpm,,9,)}</b></box>

Programme de création d'aide. Celle que vous êtes en train de lire. Comme vous pouvez le voir, il n'y a rien à reprocher.
